---
id: new-tenant-config
title: Creating and configuring a tenant
hide_title: true
sidebar_position: 3
description: >-
  Create and configure tenants with third-party login in SuperTokens for
  multi-tenant systems.
---

import { BackendTabs } from "/src/components/Tabs";
import { PythonSyncAsyncCard } from "/src/components/Cards";


# Creating and configuring a tenant

## 1. Create a tenant and enable third party login for them

The first step in setting up a multi tenant login system is to create a tenant in the SuperTokens core. Each tenant has a unique `tenantId` (a string data type) mapped to that tenant's configuation. The `tenantId` could be that tenant's sub domain, or a workspace URL, or anything else using which you can uniquely identify them.

The configuration mapped to each tenant contains information about which login methods they enable. You can create a tenant via our backend SDK or via a cURL command to the core. This also allows you to dynamically create tenants without manual intervention:

## 2. Configure the third party providers for the tenant

Once you have created a tenant with third party enabled, you need to configure which third party providers to enable for the tenant. Several [in built providers](/docs/authentication/social/built-in-providers-config) are available, but you can also configure [a custom provider](./custom-provider).

Once again, you can add / modify this configuration dynamically using our backend SDK or using a cURL command.

- The above code snippet shows how you can add an Active directory login to your tenant. The `clientId`, `clientSecret` and `directoryId` are provided to you by your tenant.
- You can see the required information for other providers [on this page](/docs/authentication/social/built-in-providers-config).

:::info Success
You have successfully configured a new tenant in SuperTokens. The next step is to wire up the frontend SDK to show the right login UI for this tenant. The specifics of this step depend on the UX that you want to provide to your users, but we have two common UX flows documented in the next section.
:::

## Providing additional configuration per tenant

You can also configure a tenant to have different configurations per the core's `config.yaml` (or docker environment variables). Below is how you can specify the configuration, when creating or modifying a tenant:

<BackendTabs additionalValues={[{ value: "dashboard", label: "Dashboard" }, { value: "curl", label: "cURL" }]}>

<BackendTabs.TabItem value="nodejs">

```tsx
import Multitenancy from "supertokens-node/recipe/multitenancy";

async function createNewTenant() {

    // highlight-start
    let resp = await Multitenancy.createOrUpdateTenant("customer1", {
        coreConfig: {
            "email_verification_token_lifetime": 7200000,
            "password_reset_token_lifetime": 3600000,
            "postgresql_connection_uri": "postgresql://localhost:5432/db2",
        }
    });
    // highlight-end

    if (resp.createdNew) {
        // new tenant was created
    } else {
        // existing tenant's config was modified.
    }
}
```

In the above example, different values are set for certain configurations for `customer1` tenant. All other configurations are inherited from the base configuration (config.yaml file or docker environment variables).

We even specify a `postgresql_connection_uri` configuration. This means that all the information related to this tenant (users, roles, metadata etc) is saved in the db pointed to by the value of `postgresql_connection_uri` (A similar configuration exists for MySQL as well). **This can achieve data isolation on a tenant level**. This configuration is not necessary and if not provided, the tenant's information is stored in the db as specified in the core's config.yaml or docker environment variables (it is still a different user pool though).

[Here is the list of full core configuration variables](https://github.com/supertokens/supertokens-core/blob/master/config.yaml) that can be configured, and below are the lists of variables depending on the database you use:
- [PostgreSQL configs](https://github.com/supertokens/supertokens-postgresql-plugin/blob/master/config.yaml)
- [MySQL configs](https://github.com/supertokens/supertokens-mysql-plugin/blob/master/config.yaml)

:::info Important
Some configurations cannot be different across tenants - they must be the same within an `app`. In the above links, if a configuration has a comment saying `DIFFERENT_ACROSS_TENANTS`, then it can be changed for each tenant, else if it has `DIFFERENT_ACROSS_APPS`, then it must be the same for all tenants within an `app`.

If a configuration has neither of these, then it can only be set per core instance.
:::

</BackendTabs.TabItem>
<BackendTabs.TabItem value="go">

```go
import (
	"github.com/supertokens/supertokens-golang/recipe/multitenancy"
	"github.com/supertokens/supertokens-golang/recipe/multitenancy/multitenancymodels"
)

func main() {
	tenantId := "customer1"

  // highlight-start
	resp, err := multitenancy.CreateOrUpdateTenant(tenantId, multitenancymodels.TenantConfig{
		CoreConfig: map[string]interface{}{
			"email_verification_token_lifetime": 7200000,
			"password_reset_token_lifetime": 3600000,
			"postgresql_connection_uri": "postgresql://localhost:5432/db2",
		},
	})
  // highlight-end

	if err != nil {
		// handle error
	}
	if resp.OK.CreatedNew {
		// new tenant was created
	} else {
		// existing tenant's config was modified.
	}
}
```

In the above example, different values are set for certain configurations for `customer1` tenant. All other configurations are inherited from the base configuration (config.yaml file or docker environment variables).

We even specify a `postgresql_connection_uri` configuration. This means that all the information related to this tenant (users, roles, metadata etc) is saved in the db pointed to by the value of `postgresql_connection_uri` (A similar configuration exists for MySQL as well). **This can achieve data isolation on a tenant level**. This configuration is not necessary and if not provided, the tenant's information is stored in the db as specified in the core's config.yaml or docker environment variables (it is still a different user pool though).

[Here is the list of full core configuration variables](https://github.com/supertokens/supertokens-core/blob/master/config.yaml) that can be configured, and below are the lists of variables depending on the database you use:
- [PostgreSQL configs](https://github.com/supertokens/supertokens-postgresql-plugin/blob/master/config.yaml)
- [MySQL configs](https://github.com/supertokens/supertokens-mysql-plugin/blob/master/config.yaml)

:::info Important
Some configurations cannot be different across tenants - they must be the same within an `app`. In the above links, if a configuration has a comment saying `DIFFERENT_ACROSS_TENANTS`, then it can be changed for each tenant, else if it has `DIFFERENT_ACROSS_APPS`, then it must be the same for all tenants within an `app`.

If a configuration has neither of these, then it can only be set per core instance.
:::

</BackendTabs.TabItem>
<BackendTabs.TabItem value="python">

<PythonSyncAsyncCard>
<PythonSyncAsyncCard.Content value="asyncio">

```python
from supertokens_python.recipe.multitenancy.asyncio import create_or_update_tenant
from supertokens_python.recipe.multitenancy.interfaces import TenantConfigCreateOrUpdate

async def some_func():
    tenant_id = "customer1"
    result = await create_or_update_tenant(tenant_id, TenantConfigCreateOrUpdate(
        core_config={
            "email_verification_token_lifetime": 7200000,
            "password_reset_token_lifetime": 3600000,
            "postgresql_connection_uri": "postgresql://localhost:5432/db2",
        },
    ))

    if result.status != "OK":
        print("handle error")
    elif result.created_new:
        print("new tenant created")
    else:
        print("existing tenant's config was modified.")
```

</PythonSyncAsyncCard.Content>

<PythonSyncAsyncCard.Content value="syncio">

```python
from supertokens_python.recipe.multitenancy.syncio import create_or_update_tenant
from supertokens_python.recipe.multitenancy.interfaces import TenantConfigCreateOrUpdate

tenant_id = "customer1"
result = create_or_update_tenant(tenant_id, TenantConfigCreateOrUpdate(
    core_config={
        "email_verification_token_lifetime": 7200000,
        "password_reset_token_lifetime": 3600000,
        "postgresql_connection_uri": "postgresql://localhost:5432/db2",
    },
))

if result.status != "OK":
    print("handle error")
elif result.created_new:
    print("new tenant created")
else:
    print("existing tenant's config was modified.")
```

</PythonSyncAsyncCard.Content>
</PythonSyncAsyncCard>

In the above example, different values are set for certain configurations for `customer1` tenant. All other configurations are inherited from the base configuration (config.yaml file or docker environment variables).

We even specify a `postgresql_connection_uri` configuration. This means that all the information related to this tenant (users, roles, metadata etc) is saved in the db pointed to by the value of `postgresql_connection_uri` (A similar configuration exists for MySQL as well). **This can achieve data isolation on a tenant level**. This configuration is not necessary and if not provided, the tenant's information is stored in the db as specified in the core's config.yaml or docker environment variables (it is still a different user pool though).

[Here is the list of full core configuration variables](https://github.com/supertokens/supertokens-core/blob/master/config.yaml) that can be configured, and below are the lists of variables depending on the database you use:
- [PostgreSQL configs](https://github.com/supertokens/supertokens-postgresql-plugin/blob/master/config.yaml)
- [MySQL configs](https://github.com/supertokens/supertokens-mysql-plugin/blob/master/config.yaml)

:::info Important
Some configurations cannot be different across tenants - they must be the same within an `app`. In the above links, if a configuration has a comment saying `DIFFERENT_ACROSS_TENANTS`, then it can be changed for each tenant, else if it has `DIFFERENT_ACROSS_APPS`, then it must be the same for all tenants within an `app`.

If a configuration has neither of these, then it can only be set per core instance.
:::

</BackendTabs.TabItem>

<BackendTabs.TabItem value="curl">

In the above example, different values are set for certain configurations for `customer1` tenant. All other configurations are inherited from the base configuration (config.yaml file or docker environment variables).

We even specify a `postgresql_connection_uri` configuration. This means that all the information related to this tenant (users, roles, metadata etc) is saved in the db pointed to by the value of `postgresql_connection_uri` (A similar configuration exists for MySQL as well). **This can achieve data isolation on a tenant level**. This configuration is not necessary and if not provided, the tenant's information is stored in the db as specified in the core's config.yaml or docker environment variables (it is still a different user pool though).

[Here is the list of full core configuration variables](https://github.com/supertokens/supertokens-core/blob/master/config.yaml) that can be configured, and below are the lists of variables depending on the database you use:
- [PostgreSQL configs](https://github.com/supertokens/supertokens-postgresql-plugin/blob/master/config.yaml)
- [MySQL configs](https://github.com/supertokens/supertokens-mysql-plugin/blob/master/config.yaml)

:::info Important
Some configurations cannot be different across tenants - they must be the same within an `app`. In the above links, if a configuration has a comment saying `DIFFERENT_ACROSS_TENANTS`, then it can be changed for each tenant, else if it has `DIFFERENT_ACROSS_APPS`, then it must be the same for all tenants within an `app`.

If a configuration has neither of these, then it can only be set per core instance.
:::

</BackendTabs.TabItem>

<BackendTabs.TabItem value="dashboard" className="tab-with-background">

<img src="/img/dashboard/tenant-management/custom-tenant-configuration.png" alt="Custom tenant configuration"/>

In the above example, different values are set for certain configurations for `customer1` tenant. All other configurations are inherited from the base configuration (config.yaml file or docker environment variables).

The values can be modified by clicking on the pencil icon and then specifying a new value.   

:::info Caution

Database connection settings cannot be modified directly from the Dashboard and you may need to use the SDK or cURL to update them.

:::

</BackendTabs.TabItem>

</BackendTabs>

Once you have set the configs for a specific tenant, you can fetch the tenant info as shown below:

<BackendTabs additionalValues={[{ value: "curl", label: "cURL" }]}>

<BackendTabs.TabItem value="nodejs">

```tsx
import Multitenancy from "supertokens-node/recipe/multitenancy";

async function getTenant(tenantId: string) {

    // highlight-start
    let resp = await Multitenancy.getTenant(tenantId);
    // highlight-end

    if (resp === undefined) {
        // tenant does not exist
    } else {
        let coreConfig = resp.coreConfig;

        let firstFactors = resp.firstFactors;

        let configuredThirdPartyProviders = resp.thirdParty.providers;
    }
}
```

</BackendTabs.TabItem>
<BackendTabs.TabItem value="go">

```go
import (
  "fmt"

	"github.com/supertokens/supertokens-golang/recipe/multitenancy"
)

func main() {
	tenantId := "customer1"

  // highlight-start
	tenant, err := multitenancy.GetTenant(tenantId)
  // highlight-end

	if err != nil {
		// handle error
	}
	if tenant == nil {
		// tenant does not exist
	} else {
		isEmailPasswordLoginEnabled := tenant.EmailPassword.Enabled;
		isThirdPartyLoginEnabled := tenant.ThirdParty.Enabled;
		isPasswordlessLoginEnabled := tenant.Passwordless.Enabled;

		if (isEmailPasswordLoginEnabled) {
			// Tenant support email password login
		}
	
		if (isThirdPartyLoginEnabled) {
			// Tenant support third party login
			configuredThirdPartyProviders := tenant.ThirdParty.Providers;
			fmt.Println(configuredThirdPartyProviders);
		}
	
		if (isPasswordlessLoginEnabled) {
			// Tenant support passwordless login
		}
	}
}
```

</BackendTabs.TabItem>
<BackendTabs.TabItem value="python">

<PythonSyncAsyncCard>
<PythonSyncAsyncCard.Content value="asyncio">

```python
from supertokens_python.recipe.multitenancy.asyncio import get_tenant

async def some_func():
    tenant = await get_tenant("customer1")

    if tenant is None:
        print("tenant does not exist")
    else:
        core_config = tenant.core_config
        first_factors = tenant.first_factors
        providers = tenant.third_party_providers
        
        print(core_config)
        print(first_factors)
        print(providers)
```

</PythonSyncAsyncCard.Content>

<PythonSyncAsyncCard.Content value="syncio">

```python
from supertokens_python.recipe.multitenancy.syncio import get_tenant

tenant = get_tenant("customer1")

if tenant is None:
    print("tenant does not exist")
else:
    core_config = tenant.core_config
    first_factors = tenant.first_factors
    providers = tenant.third_party_providers
    
    print(core_config)
    print(first_factors)
    print(providers)
```

</PythonSyncAsyncCard.Content>
</PythonSyncAsyncCard>

</BackendTabs.TabItem>

<BackendTabs.TabItem value="curl">

Notice that `customer1` is added to the path of the request. This tells the core that the tenant you want to get the information about is `customer1` (the one created before in this page).

If the input tenant does not exist, you receive a `200` status code with the following JSON:

```json
{"status": "TENANT_NOT_FOUND_ERROR"}
```

Otherwise you receive a `200` status code with the following JSON output:

```json
{
  "status": "OK",
  "thirdParty": {
    "providers": [...]
  },
  "coreConfig": {
	"email_verification_token_lifetime": 7200000,
	"password_reset_token_lifetime": 3600000,
	"postgresql_connection_uri": "postgresql://localhost:5432/db2"
  },
  "tenantId": "customer1",
  "firstFactors": ["emailpassword", "thirdparty", "otp-email", "otp-phone", "link-email", "link-phone"]
}
```

</BackendTabs.TabItem>

</BackendTabs>

The returned `coreConfig` is the same as what was set when creating / updating the tenant. The rest of the core configurations for this tenant are inherited from the `app`'s (or the `public` tenant) configuration. The `public` tenant, for the `public` `app` inherits its configurations from the `config.yaml` / docker environment variables values.
