---
title: Security
hide_title: true
sidebar_position: 5
description: >-
  Learn how to protect your website from CSRF attacks using the `sameSite`
  cookie attribute.
---

import { BackendTabs, SelfHostingTabs } from "/src/components/Tabs";


# Session Security

## Overview


---

## Anti CSRF

CSRF attacks can happen if a logged in user visits a malicious website which makes an API call to your website's API to maliciously change that user's data.
To protect against this attack, we use the cookie `sameSite` attribute along with some anti-csrf measures.
This attribute is used to declare if your cookies should be restricted to a first-party or same-site context.
Properly configuring `sameSite` can prevent CSRF attacks.

For example, if `sameSite` is `lax`, the browser will only send cookies for requests that originate from the same top level domain as the API's domain.
So if a user visits a malicious site, requests from those sites will not have the session cookies.

### Configure anti-csrf

:::caution
- SuperTokens automatically defends against CSRF attacks.
- Please only change this setting if you know what you are doing. If you are unsure, please feel free to [ask questions to us](https://supertokens.com/discord).
- This setting is ignored while using header-based authentication, since they get the same protection as `antiCsrf` set to `VIA_CUSTOM_HEADER`.
:::

You can change the `antiCsrf` configuration option to take control of the kind of protection you get.
You can use on of the following values:

- `"NONE"` would disable any anti-csrf protection from our end.
You can use this if you have your own implementation of CSRF protection.
- `"VIA_CUSTOM_HEADER"` uses [this method](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#use-of-custom-request-headers) to prevent CSRF protection.
This is set automatically if `sameSite` is `none` or if your `apiDomain` and `websiteDomain` do not share the same top level domain name.
- `"VIA_TOKEN"` uses an explicit anti-csrf token.
Use this method if you want to allow any origin to query your APIs.
This method may cause issues in browsers like Safari, especially if your site is embedded as an `iframe`.

<BackendTabs>
<BackendTabs.TabItem value="nodejs">

```tsx
import SuperTokens from "supertokens-node";
import Session from "supertokens-node/recipe/session";

SuperTokens.init({
    supertokens: {
        connectionURI: "...",
    },
    appInfo: {
        apiDomain: "...",
        appName: "...",
        websiteDomain: "..."
    },
    recipeList: [
        Session.init({
            // highlight-next-line
            antiCsrf: "VIA_CUSTOM_HEADER",  // Should be one of "NONE" or "VIA_CUSTOM_HEADER" or "VIA_TOKEN"
        })
    ]
});
```
</BackendTabs.TabItem>
<BackendTabs.TabItem value="go">

```go
import (
	"github.com/supertokens/supertokens-golang/recipe/session"
	"github.com/supertokens/supertokens-golang/recipe/session/sessmodels"
	"github.com/supertokens/supertokens-golang/supertokens"
)

func main() {
	// highlight-start
	// Should be one of "NONE" or "VIA_CUSTOM_HEADER" or "VIA_TOKEN"
	antiCsrf := "VIA_CUSTOM_HEADER"
	// highlight-end

	supertokens.Init(supertokens.TypeInput{
		RecipeList: []supertokens.Recipe{
			session.Init(&sessmodels.TypeInput{
				// highlight-next-line
				AntiCsrf: &antiCsrf,
			}),
		},
	})
}
```
</BackendTabs.TabItem>
<BackendTabs.TabItem value="python">

```python
from supertokens_python import init, InputAppInfo
from supertokens_python.recipe import session

init(
    app_info=InputAppInfo(api_domain="...", app_name="...", website_domain="..."),
    framework='...', # type: ignore
    recipe_list=[
        session.init(
            # highlight-start
            # Should be one of "NONE" or "VIA_CUSTOM_HEADER" or "VIA_TOKEN"
            anti_csrf='VIA_CUSTOM_HEADER'
            # highlight-end
        )
    ]
)
```

</BackendTabs.TabItem>
</BackendTabs>

---

## Cookie Consent

[As per GDPR](https://gdpr.eu/cookies/), users do not need to give consent for your application to use session cookies. This is because they fall under essential cookies and not tracking cookies:

:::info Important
"While it is not required to obtain consent for these cookies, what they do and why they are necessary should be explained to the user."
:::

---

## Same site cookies

To ensure session cookies are protected from [CSRF attacks](./anti-csrf#what-is-a-csrf-attack) the ``sameSite`` cookie attribute is set.
The ``sameSite`` cookie attribute is used to declare if your cookies should be restricted to a first-party or same-site context.
The ``sameSite`` attribute can be set to three possible values:
- ``none``
  - Cookies will be sent in all contexts, i.e cookies will be attached to both first-party and cross-origin requests.
  - On Safari however, if third party cookies are blocked (which is the default behaviour), and the website and `API` domains do not share the same top level domain, then cookies won't go. Please check [here](/docs/post-authentication/session-management/advanced-workflows/switch-between-cookies-and-header-authentication) to see how you can switch to using headers.
- ``lax``
  - Cookies will only be sent in a first-party context and along with `GET` requests initiated by third party websites (that result in browser navigation - user clicking on a link).
- ``strict``
  - Cookies will only be sent in a first-party context and not be sent along with requests initiated by third party websites.

### Configuration

:::caution
- SuperTokens will automatically set the value of the ``sameSite`` cookie attribute based on your website and `API` domain configration.
- Please only change this setting if you are a web security expert. If you are unsure, please feel free to [ask questions to us](https://supertokens.com/discord).
:::

<BackendTabs>
<BackendTabs.TabItem value="nodejs">

```tsx
import SuperTokens from "supertokens-node";
import Session from "supertokens-node/recipe/session";

SuperTokens.init({
    supertokens: {
        connectionURI: "...",
    },
    appInfo: {
        apiDomain: "...",
        appName: "...",
        websiteDomain: "..."
    },
    recipeList: [
        Session.init({
            // highlight-next-line
            cookieSameSite: "strict", // Should be one of "strict" or "lax" or "none"
        }),
    ],
});
```

</BackendTabs.TabItem>
<BackendTabs.TabItem value="go">

```go
import (
	"github.com/supertokens/supertokens-golang/recipe/session"
	"github.com/supertokens/supertokens-golang/recipe/session/sessmodels"
	"github.com/supertokens/supertokens-golang/supertokens"
)

func main() {
	// highlight-start
	// Should be one of "strict" or "lax" or "none"
	cookieSameSite := "lax"
	// highlight-end

	supertokens.Init(supertokens.TypeInput{
		RecipeList: []supertokens.Recipe{
			session.Init(&sessmodels.TypeInput{
				// highlight-next-line
				CookieSameSite: &cookieSameSite,
			}),
		},
	})
}
```

</BackendTabs.TabItem>
<BackendTabs.TabItem value="python">

```python
from supertokens_python import init, InputAppInfo
from supertokens_python.recipe import session


init(
    app_info=InputAppInfo(api_domain="...", app_name="...", website_domain="..."),
    framework='...', # type: ignore
    recipe_list=[
        session.init(
            # highlight-start
            cookie_same_site='lax' # Should be one of 'strict' or 'lax' or 'none'
            # highlight-end
        )
    ]
)
```

</BackendTabs.TabItem>
</BackendTabs>

---

## Cookies and HTTPS

SuperTokens ensures that cookies are secured by enabling the ``secure`` flag when generating session cookies.
When set, the ``secure`` attribute limits the scope of the cookie to be attached only to secure domains. 
This results in the cookie only being attached to requests transmitted over `https`.
This, in turn, prevents cookie theft via man in the middle attacks.

You can explicitly set the security level of cookies using the next snippet:

:::important
If not explicitly set, SuperTokens automatically determines the value for the `secure` attribute based on your API domain having `http` or `https`.
:::

<BackendTabs>
<BackendTabs.TabItem value="nodejs">

```tsx
import SuperTokens from "supertokens-node";
import Session from "supertokens-node/recipe/session";

SuperTokens.init({
    supertokens: {
        connectionURI: "...",
    },
    appInfo: {
        apiDomain: "...",
        appName: "...",
        websiteDomain: "..."
    },
    recipeList: [
        Session.init({
            //highlight-next-line
            cookieSecure: true,
        })
    ]
});
```
</BackendTabs.TabItem>
<BackendTabs.TabItem value="go">

```go
import (
	"github.com/supertokens/supertokens-golang/recipe/session"
	"github.com/supertokens/supertokens-golang/recipe/session/sessmodels"
	"github.com/supertokens/supertokens-golang/supertokens"
)

func main() {
	// highlight-next-line
	cookieSecure := true

	supertokens.Init(supertokens.TypeInput{
		RecipeList: []supertokens.Recipe{
			session.Init(&sessmodels.TypeInput{
				// highlight-next-line
				CookieSecure: &cookieSecure,
			}),
		},
	})
}
```
</BackendTabs.TabItem>
<BackendTabs.TabItem value="python">

```python
from supertokens_python import init, InputAppInfo
from supertokens_python.recipe import session

init(
    app_info=InputAppInfo(api_domain="...", app_name="...", website_domain="..."),
    framework='...', # type: ignore
    recipe_list=[
        session.init(
            # highlight-start
            cookie_secure=True
            # highlight-end
        )
    ]
)
```

</BackendTabs.TabItem>
</BackendTabs>

---


## Access Token signing key rotation

Access Token signing key rotation implies that the secret key for signing the access tokens will be changed at a fixed time interval. This reduces the risk of key theft.

:::info
- Existing logged in users are not logged out on key change.
- This feature is enabled by default.
:::

### Change the key rotation interval


<SelfHostingTabs>
<SelfHostingTabs.TabItem value="with-docker">

```bash
docker run \
  -p 3567:3567 \
  // highlight-start
  -e ACCESS_TOKEN_DYNAMIC_SIGNING_KEY_UPDATE_INTERVAL=168 \
  // highlight-end
  -d registry.supertokens.io/supertokens/supertokens-<db name>
```

</SelfHostingTabs.TabItem>

<SelfHostingTabs.TabItem value="without-docker">

```yaml
# You need to add the following to the config.yaml file.
# The file path can be found by running the "supertokens --help" command

access_token_dynamic_signing_key_update_interval: 168

```
</SelfHostingTabs.TabItem>
</SelfHostingTabs>

- ``access_token_dynamic_signing_key_update_interval``
  - Time in hours for how frequently the signing key will change.
  - It must be set to a ``number`` value with, the default value set to ``168``

:::info
For managed service, this value can be updated by visiting our dashboard.
:::

### Use static keys

If you do not want to use dynamic keys for session creation, then you can tell SuperTokens to use the static key instead. This is useful in cases where you want to [hard-code the public key for JWT verification in some process](/docs/additional-verification/session-verification/protect-api-routes#with-the-public-key-string).

<BackendTabs>
<BackendTabs.TabItem value="nodejs">

```tsx
import SuperTokens from "supertokens-node";
import Session from "supertokens-node/recipe/session";

SuperTokens.init({
    supertokens: {
        connectionURI: "...",
    },
    appInfo: {
        apiDomain: "...",
        appName: "...",
        websiteDomain: "..."
    },
    recipeList: [
        Session.init({
            //highlight-next-line
            useDynamicAccessTokenSigningKey: false,
        })
    ]
});
```

:::caution
Updating this value will cause a spike in the session refresh API, as and when users visit your application.
:::

</BackendTabs.TabItem>
<BackendTabs.TabItem value="go">

```go
import (
	"github.com/supertokens/supertokens-golang/recipe/session"
	"github.com/supertokens/supertokens-golang/recipe/session/sessmodels"
	"github.com/supertokens/supertokens-golang/supertokens"
)

func main() {
	// highlight-next-line
	useDynamicAccessTokenSigningKey := false

	supertokens.Init(supertokens.TypeInput{
		RecipeList: []supertokens.Recipe{
			session.Init(&sessmodels.TypeInput{
				// highlight-next-line
				UseDynamicAccessTokenSigningKey: &useDynamicAccessTokenSigningKey,
			}),
		},
	})
}
```

:::caution
Updating this value will cause a spike in the session refresh API, as and when users visit your application.
:::

</BackendTabs.TabItem>
<BackendTabs.TabItem value="python">

```python
from supertokens_python import init, InputAppInfo
from supertokens_python.recipe import session

init(
    app_info=InputAppInfo(api_domain="...", app_name="...", website_domain="..."),
    framework='...', # type: ignore
    recipe_list=[
        session.init(
            # highlight-start
            use_dynamic_access_token_signing_key=False
            # highlight-end
        )
    ]
)
```

:::caution
Updating this value will cause a spike in the session refresh API, as and when users visit your application.
:::

</BackendTabs.TabItem>
</BackendTabs>
