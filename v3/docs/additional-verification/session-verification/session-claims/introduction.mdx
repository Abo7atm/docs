---
title: Introduction
hide_title: true
sidebar_position: 1
toc_max_heading_level: 4
description: >-
  Guide on using SuperTokens claim validators to manage session access and
  custom claims.
---

import {
  FrontendPrebuiltUITabs,
  FrontendCustomUITabs,
  BackendTabs,
  ReactRouterVersionTabs,
} from "/src/components/Tabs";
import { NpmOrScriptsCard, MobileFrameworksCard, PythonSyncAsyncCard, NodeFrameworksCard, PythonFrameworksCard, GoFrameworksCard } from "/src/components/Cards";
import { ContextCondition } from "/src/components";

# Introduction


## Overview


## Before you start


<TokensCallout />


## References

### Session claims

SuperTokens session has a property called `accessTokenPayload`. This is a `JSON` object that's stored in a user's session which can be accessed on the frontend and backend. The key-values in this JSON payload are called claims.

### Session claim validators

Session claim validators check if the the claims in the session meet a certain criteria before giving access to a resource.

Let's take two examples:
- 2FA session claim validator: This validator checks if the session claims indicates that the user has completed both the auth factors or not.
- Email verification claim validator: This checks if the user's session indicates if they have verified their email or not.

In either case, the claim validators base their checks on the claims (or properties) present in the session's access token payload. These claims can be added by you or by the SuperTokens SDK (ex, the user roles recipe adds the roles claims to the session).

This document will guide you through how to use prebuilt session claims and session claims validators as well as how to build your own.

## Why do we need session claim validators?
The claims in the payload represent the state of the user's access properties. Session claim validators ensure that the state is up to date when the claims are being checked.

For example, if during sign in, the user has the role of `"user"`, this will be added to their session by SuperTokens. If during the course of their session, the user is upgraded to an `"admin"` role, then the session claim needs to be updated to reflect this as well. To do this automatically, the claim validator for roles will auto refresh the role in the session periodically. You can even specify that you want to force refresh the state when using the validator in your APIs.

Without a special construct of session claim validators, the updating of the session claims would have to be done manually by you (the developer), so to save you the time and effort, we introduced this concept.

### Session claim interface

#### On the backend

Before we dive deep into claim validators, let's talk about session claim objects. These are objects that conform to an interface that allows SuperTokens to automatically add session claims to the access token payload. Here is the interface:

```tsx

import { RecipeUserId } from "supertokens-node";

type JSONObject = any; // REMOVE_FROM_OUTPUT
interface SessionClaim<T> {
    readonly key: string;

    fetchValue(userId: string, recipeUserId: RecipeUserId, tenantId: string, currentPayload: JSONObject | undefined, userContext: any): Promise<T | undefined>;

    addToPayload_internal(payload: JSONObject, value: T, userContext: any): JSONObject;

    removeFromPayloadByMerge_internal(payload: JSONObject, userContext: any): JSONObject;

    removeFromPayload(payload: JSONObject, userContext: any): JSONObject;

    getValueFromPayload(payload: JSONObject, userContext: any): T | undefined;

    getLastRefetchTime(payload: JSONObject, userContext: any): number | undefined;
}
```
- `T` represents a generic type. For a `boolean` claim (for example if the email is verified or not), the type of `T` is a `boolean`.
- `fetchValue` is responsible for fetching the value of the claim from its source. For example, the email verification claim uses the `EmailVerification.isEmailVerified` function from the email verification recipe to return a `boolean` from this function.
- `addToPayload_internal` function is responsible for adding the claim value to the input `payload` and returning the modified payload. The payload here represents the access token's payload. Some of the in built claims in the SDK modify the payload in the following way:
    ```text
    {
        ...payload,
        "<key>": {
            "t": <current time in milliseconds>,
            "v": <value>
        }
    }
    ```

    The `key` variable is an input to the `constructor`. For the in built email verification claim, the value of `key` is `"st-ev"`.
- `removeFromPayloadByMerge_internal` function is responsible for modifying the input `payload` to remove the claim in such a way that if `mergeIntoAccessTokenPayload` is called, then it would remove that claim from the payload. This usually means modifying the payload like:
    ```text
    {
        ...payload,
        "<key>": null
    }
    ```
- `removeFromPayload` function is similar to the previous function, except that it deletes the `key` from the input `payload` entirely.
- `getValueFromPayload` function is supposed to return the claim's value given the input `payload`. For the in built claims, it's usually `payload[<key>][v]` or `undefined` of the `key` doesn't exist in the `payload`.
- `getLastRefetchTime` function returns the last time (in milliseconds) since this claim was fetched. If the claim doesn't exist in the `payload`, this function returns `undefined`.

The SDK provides a few base claim classes which make it easy for you to implement your own claims:
- [`PrimitiveClaim`](https://github.com/supertokens/supertokens-node/blob/master/lib/ts/recipe/session/claimBaseClasses/primitiveClaim.ts): Can be used to add any primitive type value (`boolean`, `string`, `number`) to the session payload.
- [`PrimitiveArrayClaim`](https://github.com/supertokens/supertokens-node/blob/master/lib/ts/recipe/session/claimBaseClasses/primitiveArrayClaim.ts): Can be used to add any primitive array type value (`boolean[]`, `string[]`, `number[]`) to the session payload.
- [`BooleanClaim`](https://github.com/supertokens/supertokens-node/blob/master/lib/ts/recipe/session/claimBaseClasses/booleanClaim.ts): A special case of the `PrimitiveClaim`, used to add a `boolean` type claim.

Using these, we have built a few useful claims:
- [`EmailVerificationClaim`](https://github.com/supertokens/supertokens-node/blob/master/lib/ts/recipe/emailverification/emailVerificationClaim.ts): This is used to store info about if the user has verified their email.
- [`RolesClaim`](https://github.com/supertokens/supertokens-node/blob/master/lib/ts/recipe/userroles/userRoleClaim.ts): This is used to store the list of roles associated with a user.
- [`PermissionClaim`](https://github.com/supertokens/supertokens-node/blob/master/lib/ts/recipe/userroles/permissionClaim.ts): This is used to store the list of permissions associated with the user.

You can image all sorts of claims that can be built further:
- If the user has completed 2FA or not
- If the user has filled in all the profile info post sign up or not
- The last time the user authenticated themselves (useful for if you want to ask the user for their password after a certain time period).

#### On the frontend

Just like the backend, the frontend also has the concept of Session claim objects which need to conform to the following interface:

```tsx
type SessionClaim<T> = {
    refresh(): Promise<void>;

    getValueFromPayload(payload: any): T | undefined;
    
    getLastFetchedTime(payload: any): number | undefined;
};
```
- The `refresh` function is responsible for refreshing the claim values in the session via an API call. The API call is expected to update the claim values if required.

- `getValueFromPayload` helps with reading the value from the session claim. 

- `getLastFetchedTime` reads the claim to return the timestamp (in milliseconds) of the last time the claim was refreshed. 

When used, these objects provide a way for the SuperTokens SDK to update the claim values as and when needed. For example, in the built-in email verification claim, the `refresh` function calls the backend API to check if the email is verified. That API in turn updates the session claim to reflect the email verification status. This way, even if the email was marked as verified in offline mode, the frontend will be able to get the email verification status update automatically.

Just like the backend SDK, the frontend SDK also exposes a few base claims:
- [`BooleanClaim`](https://github.com/supertokens/supertokens-website/blob/master/lib/ts/claims/booleanClaim.ts)
- [`PrimitiveClaim`](https://github.com/supertokens/supertokens-website/blob/master/lib/ts/claims/primitiveClaim.ts)
- [`PrimitiveArrayClaim`](https://github.com/supertokens/supertokens-website/blob/master/lib/ts/claims/primitiveArrayClaim.ts)

### Claim validator interface

#### On the backend

Once a claim is added to the session, we must specify the checks that need to run on them during session verification. For example, if we want an API to be guarded so that only `admin` roles can access them, we need a way to tell SuperTokens to do that check. This is where claim validators come into the picture. Here is the shape for a claim validator object:

```tsx
type SessionClaim<T> = any; // REMOVE_FROM_OUTPUT
type SessionClaimValidator = {
    id: string;

    claim: SessionClaim<any>;

    shouldRefetch: (payload: any, userContext: any) => Promise<boolean>;

    validate: (payload: any, userContext: any) => Promise<ClaimValidationResult>;
};

type ClaimValidationResult = { isValid: true } | { isValid: false; reason?: any };
```

- The `id` is used to identify the session claim validator. This is useful to know which validator failed in case several of them are being checked at the same time. The value of this is usually the same as the claim object's `key`, but it can be set to anything else.

- The `claim` property is a reference to the claim object that's associated with this validator. The `shouldRefetch` and `validate` functions will use `claim.getValueFromPayload` to fetch the claim value from the input `payload`.

- `shouldRefetch` is a function which determines if the value of the claim should be fetched again. In the in built validators, this function usually returns `true` if the claim does not exist in the `payload`, or if it's too old.

- `validate` function extracts the claim value from the input `payload` (usually using `claim.getValueFromPayload`), and determines if the validator check has passed or not. For example, if the validator is supposed to enforce that the user's email is verified, and if the claim value is `false`, then this function would return:
    ```text
    {
        isValid: false,
        message: "wrong value",
        expectedValue: true,
        actualValue: false
    }
    ```

Using this interface and the claims interface, SuperTokens runs the following session claim validation process during session verification:
```text
function validateSessionClaims(accessToken, claimValidators[]) {
    payload = accessToken.getPayload();
    
    // Step 1: refetch claims if required
    foreach validator in claimValidators {
        if (validator.shouldRefetch(payload)) {
            claimValue = validator.claim.fetchValue(accessToken.sub)
            payload = validator.claim.addToPayload_internal(payload, claimValue) 
        }
    }

    failedClaims = []

    // Step 2: Validate all claims
    foreach validator in claimValidators {
        validationResult = validator.validate(payload)
        if (!validationResult.isValid) {
            failedClaims.push({id: validator.id, reason: validationResult.reason})
        }
    }

    return failedClaims
}
```

The built-in base claims (`PrimitiveClaim`, `PrimitiveArrayClaim`, `BooleanClaim`) all expose a set of useful validators:
- [`PrimitiveClaim.validators.hasValue(val, maxAgeInSeconds?)`](https://github.com/supertokens/supertokens-node/blob/master/lib/ts/recipe/session/claimBaseClasses/primitiveClaim.ts#L50): This function call returns a validator object that enforces that the session claim has the specified `val`.

- [`PrimitiveArrayClaim.validators.includes(val, maxAgeInSeconds?)`](https://github.com/supertokens/supertokens-node/blob/master/lib/ts/recipe/session/claimBaseClasses/primitiveArrayClaim.ts#L50): This checks if the the session claims value, which is an array, includes the input `val`.

- [`PrimitiveArrayClaim.validators.excludes(val, maxAgeInSeconds?)`](https://github.com/supertokens/supertokens-node/blob/master/lib/ts/recipe/session/claimBaseClasses/primitiveArrayClaim.ts#L91): This checks if the the session claims value, which is an array, excludes the input `val`.

- [`PrimitiveArrayClaim.validators.includesAll(val[], maxAgeInSeconds?)`](https://github.com/supertokens/supertokens-node/blob/master/lib/ts/recipe/session/claimBaseClasses/primitiveArrayClaim.ts#L136): This checks if the the session claims value, which is an array, includes all of the items in the input `val[]`.

- [`PrimitiveArrayClaim.validators.excludesAll(val[], maxAgeInSeconds?)`](https://github.com/supertokens/supertokens-node/blob/master/lib/ts/recipe/session/claimBaseClasses/primitiveArrayClaim.ts#L178): This checks if the the session claims value, which is an array, excludes all of the items in the input `val[]`.

- The `BooleanClaim` is built on top of the `PrimitiveClaim` class, so it has the same `hasValue` function, but also has additional `isTrue(maxAgeInSeconds?)` and `isFalse(maxAgeInSeconds?)` functions.

In all of the above claim validators, the `maxAgeInSeconds` input (which is optional) governs how often the session claim value should be refetched 
- A value of `0` will make it refetch the claim value each time a check happens.
- If not passed, the claim will only be refetched if it's missing in the session. The in built claims like email verification or user roles claims have a default value of five minutes, meaning that those claim values are refreshed from the database after every five minutes.

#### On the frontend

<UIType.Switch />

Just like the backend, the frontend too has session claim validators that conform to the following shape

<UIType.PrebuiltUIContent>

```tsx
type SessionClaimValidator = {
    readonly id: string;

    refresh(): Promise<void>;

    shouldRefresh(accessTokenPayload: any): Promise<boolean> | boolean;

    validate(
        accessTokenPayload: any
    ): Promise<ClaimValidationResult> | ClaimValidationResult;
    
    onFailureRedirection?: (({ userContext, reason }: { userContext: any; reason: any }) => Promise<string | undefined> | string | undefined);
    showAccessDeniedOnFailure?: boolean;
}

type ClaimValidationResult = { isValid: true } | { isValid: false; reason?: any };
```

</UIType.PrebuiltUIContent>

<UIType.CustomUIContent>

```tsx
type SessionClaimValidator = {
    readonly id: string;

    refresh(): Promise<void>;

    shouldRefresh(accessTokenPayload: any): Promise<boolean> | boolean;

    validate(
        accessTokenPayload: any
    ): Promise<ClaimValidationResult> | ClaimValidationResult;
}

type ClaimValidationResult = { isValid: true } | { isValid: false; reason?: any };
```

</UIType.CustomUIContent>


- The `refresh` function is the same as the one in the frontend claim interface.
- `shouldRefresh` is function which determines if the claim should be checked against the backend before calling `validate`. This usually returns `true` if the claim value is too old or if it is not present in the `accessTokenPayload`. When implementing this function for a `SessionClaimValidator` and using `Date.now`, it's advisable to use `DateProvider.now` from our SDK. This mitigates potential clock skew issues by accounting for the time difference between the frontend and backend. Use `DateProvider` as shown:

<UIType.PrebuiltUIContent>

```tsx
import { DateProviderReference } from "supertokens-auth-react/utils/dateProvider";
DateProviderReference.getReferenceOrThrow().dateProvider.now();
```

</UIType.PrebuiltUIContent>

<UIType.CustomUIContent>

```tsx
import { DateProviderReference } from "supertokens-web-js/utils/dateProvider";
DateProviderReference.getReferenceOrThrow().dateProvider.now();
```
</UIType.CustomUIContent>

- The `validate` function checks the `accessTokenPayload` for the value of the claim and returns an appropriate response. 

<UIType.PrebuiltUIContent>

- Using the `onFailureRedirection` callback, you can choose to redirect the user to a specific URL or path if the claim validation fails. The default value of this is `undefined`, which means that there will be no redirection on failure.
- By setting `showAccessDeniedOnFailure` to false, you can choose to still show the contents of SessionAuth even if the claim validation fails. The default value of this is `true`, which means that if the `SessionAuth` wrapper is supplied with a an access denied screen component, it will display that.

</UIType.PrebuiltUIContent>

The logic for how validators are run on the frontend is the same as on the backend:
- First we `refresh` the claim if that claim's `shouldRefresh` returns `true` (and we do this for all the claims)
- Then we call the `validate` function on the claims one by one to return a array of validation result.

<UIType.PrebuiltUIContent>

In case validation fails, the `SessionAuth` component will:
1. Automatically redirect the user to a related screen where the user can either resolve the issue or get more information if `onFailureRedirection` has been set up. For example, the email verification validator (in required mode) will redirect to the email verification screen, where the user can verify their email address.
2. Show an access denied screen if a component was passed in the `accessDeniedScreen` prop and the validator doesn't have `showAccessDeniedOnFailure` set to false. E.g.: role and permission claim validators will show the access denied screen.
3. Render the children with the validation error added to the session context (in `invalidClaims`) if neither of the above was applicable. E.g.: the email verification validator in `OPTIONAL` mode.

</UIType.PrebuiltUIContent>

<UIType.CustomUIContent>

In case validation fails, you can choose to render a certain UI or redirect the user. For example, if the email verification validator failed, you can redirect the user to the email verification screen or show an access denied screen until

</UIType.CustomUIContent>

And once again, just like in the backend, the frontend too exposes several helper functions like `hasValue`, `includes`, `excludes`, `isTrue` etc. for the base claim classes.

