---
title: Multiple frontend domains with a common backend 
hide_title: true
---

import BackendSDKTabs from "/src/components/tabs/BackendSDKTabs"
import TabItem from '@theme/TabItem';
import CoreInjector from "/src/components/coreInjector"
import FrontendPreBuiltUITabs from "/src/components/tabs/FrontendPreBuiltUITabs"

# Multiple Frontend Domains Using a Single Backend

You can use the following guide if you have multiple **`frontend applications`** on different domains, that use the same **`backend service`**.

Using the actual **OAuth 2.0** terminology, we can say that each **`frontend`** can be considered a [**Client**](/docs/oauth/introduction#client) and the **`backend`** will act as both an [**Authorization Server**](/docs/oauth/introduction#authorization) and a [**Resource Server**](/docs/oauth/introduction#resource-server).

:::info
This guide assumes that you already have setup and configured **SuperTokens** in your [**Authentication Service**](/docs/oauth/introduction#authentication-service). 

For more information on how to do that please check our [quickstart guide](/docs/thirdparty/introduction).
:::

## 1. Enable the OAuth2 features from the Dashboard

You will first have to enable the **OAuth2** features from the **SuperTokens Dashboard**.
1. Open the **SuperTokens Dashboard** on the main page
2. Click on the **Enabled Paid Features** button
3. Click on **Managed Service**
4. Check the **OAuth 2.0** option
5. Click *Save* 

Now you should be able to use the OAuth2 recipes in your applications.

## 2. Create the OAuth2 Clients

For each of your **`frontend`** applications you will have to create a separate [**OAuth2 client**](/docs/oauth/introduction#client).
This can be done by directly calling the **SuperTokens Core** API.

<CoreInjector defaultValue="https://<your-core-identifier>.aws.supertokens.io" showTenantId={false}>

```bash
curl -X POST ^{coreInjector_uri_without_quotes}/recipe/oauth2/admin/clients \
  -H "Content-Type: application/json" \
  -H "api-key: ^{coreInjector_api_key_without_quotes}" \
  -d '{
      "client_name": "<YOUR_CLIENT_NAME>",
      "response_types": ["code", "id_token"],
      "grant_types": ["authorization_code", "refresh_token"],
      "redirect_uri": ["https://<YOUR_DOMAIN>/oauth/callback"]
    }'
```

</CoreInjector>


- `client_name` - A human-readable name of the client that will be presented to the [**end-user**](/docs/oauth/introduction#authorization) during authorization.
- `response_types` - Specifies the types of responses your client expects from the Authorization Server. Most of the time, you would need the following two to be present:
    - `code`: Indicates that the [**Client**](/#authorization) will receive an [**Authorization Code**](/#authorization) that will be exchanged for an [**Access Token**](/#authorization).
    - `id_token`: Indicates that the [**Client**](/#authorization) expects an [**ID Token**](/#authorization)
- `grant_types` - The grant types that the [**Client**](/#authorization) will use. 
    - `authorization_code`: Allows exchanging the [**Authorization Code**](/#authorization) for an [**Access Token**](/#authorization).
    - `refresh_token`: Allows exchanging the [**Refresh Token**](/#authorization) for a new [**Access Token**](/#authorization).
- `redirect_uri` - A list of URIs to which the [**Authorization Server**](/#authorization) will send the user-agent (browser) after completing the authorization step. These can be deep links to mobile or desktop apps as well, but they must be exact URLs, without wildcards.

If the creation was successful, the response will return a `201` status code.
The response body will contain the **`client_id`** and the `client_secret` fields. Save them for each request because we will need to use them in the next steps.

## 3. Initialize the OAuth2 recipes on the backend


In your **`backend`** application you will need to initialize both the **OAuth2Provider** and the **OAuth2Client** recipes.

<BackendSDKTabs>
<TabItem value="nodejs">

```typescript
import supertokens from "supertokens-node";
import OAuth2Provider from"supertokens-node/recipe/oauth2provider";
import OAuth2Client from"supertokens-node/recipe/oauth2client";

supertokens.init({
    framework: "express",
    supertokens: {
        connectionURI: "<YOUR_CONNECTION_URI>",
        apiKey: "<YOUR_API_KEY>",
    },
    appInfo: {
        appName: "",
        apiDomain: "<YOUR_API_DOMAIN>",
        websiteDomain: "<YOUR_WEBSITE_DOMAIN>",
        apiBasePath: "/auth",
        websiteBasePath: "/auth"
    },
    recipeList: [
        OAuth2Provider.init(),
        // You will have to initialize the OAuth2Client recipe
        // for each of your previously created clients 
        OAuth2Client.init({
          clientId: '<CLIENT_ID>',
          oidcDiscoveryEndpoint: 'https://<AUTHENTICATION_SERVICE_DOMAIN>/auth/.well-known/openid-configuration'
        }),
    ]
});
```

</TabItem>

<TabItem value="go">

:::caution

At the moment we do not have support creating OAuth2 providers in the Go SDK.

:::

</TabItem>

<TabItem value="python">

:::caution

At the moment we do not have support creating OAuth2 providers in the Python SDK.

:::

</TabItem>

</BackendSDKTabs>

###  Configure the Authorization Service Frontend 

:::info

The `OAuth2Provider` recipe is available, at the moment, only when using the `supertokens-auth-react` package.

:::

Initialize the `OAuth2Provider` recipe on the frontend of your **Authorization Service**, ensuring you set the `authMode` to `header`.

```tsx
import OAuth2Provider from "supertokens-auth-react/recipe/oauth2provider";
import Session from "supertokens-auth-react/recipe/session";


export const SuperTokensConfig = {
    appInfo: {
        appName: "App Name",
        apiDomain: "<AUTHENTICATION_SERVICE_DOMAIN>",
        websiteDomain: "<FRONTEND_APPLICATION_DOMAIN>",
    },
    recipeList: [
        OAuth2Provider.init({ authMode: "header" }),
        Session.init(),
    ],
};
```

## 4. Update the login flow in your frontend applications

In your `frontend applications` you will have to add a login action that will direct the user to the authentication page.
You can just use a link for that.

The link should be structured like this:

```
<AUTHENTICATION_SERIVICE_DOMAIN>/auth/oauth/auth?client_id=<CLIENT_ID>&redirect_uri=<REDIRECT_URI>&scope=<SCOPES>&state=<STATE>
```
- `<AUTHENTICATION_SERIVICE_DOMAIN>` - The domain of your [**Authentication Service**](/docs/oauth/introduction#authentication-service).
The example assumes that you didn't overwrite the default `apiBasePath`.
If that's the case you will have to replace `/auth` with you custom base path.
- `<CLIENT_ID>` - The corresponding client ID based on what you have created in the first step.
- `<REDIRECT_URI>` - The corresponding redirect URI based on what you have created in the first step.
- `<SCOPES>` - The scopes that you want to request. This is optional and can be left empty.
- `<STATE>` - A random string that will be used to prevent CSRF attacks. This is optional and can be left empty.

## 5. Test the new authentication flow

With everything set up, you can now test your login flow.
Just use the link that you have created in the previous step and try to access a protected resource.


