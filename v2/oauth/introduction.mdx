---
title: Introduction 
hide_title: true
---

# OAuth2 Support 

**OAuth2**, Open Authorization, is an industry-standard authorization framework that enables third-party applications to obtain limited access to a user's resources without exposing their credentials.
It is commonly used for single sign-on (SSO) and authorization. 

## When to use OAuth2

In most cases, when using **SuperTokens**, you should not have to use OAuth2 directly.
We already expose the **[ThirdParty Recipe](/docs/thirdparty/introduction)** that enables users to login using external providers. 
This covers most of the authentication scenarios that involve OAuth2. 

However, there are some custom use cases where you will have to implement a different authentication flow.

- **[If you have multiple frontend clients that connect to different backends](/docs)**
- **[If you have multiple frontend clients connecting to the same backend](/docs)**
- **[If you want to have an unified login experience across multiple domains](/docs)**
- **[If you want to reuse your website login for desktop and mobile apps](/docs)**
- **[For authenticating microservices](/docs)**

For these specific instances we expose recipes that allow you to complete your setup. 

## OAuth2 Reference

Before we explore the guides let's first recap some common terms and concepts that are used in the framework.
We will use them throughout the next pages.

### Providers

An **OAuth 2.0 Provider** is a server that implements the OAuth 2.0 protocol, responsible for issuing access tokens to third-party applications after authenticating users.
The provider enables those applications to access and interact with the user's resources securely and without exposing the user's credentials.

### Clients

An **OAuth 2.0 Client** is an application that interacts with an **OAuth 2.0 Provider** to request access to a user's resources. 
It then utilizes the access tokens granted by the provider to perform authorized operations on behalf of the user.

The term **client** does not imply any particular implementation characteristics (e.g. whether the application executes on a server, a desktop, or other devices).


### Tokens

An **OAuth Token** is a credential used to access protected resources on behalf of a user. 
There are several types of tokens defined by the protocol.

#### Access Token

**Access tokens** are what the **OAuth Client** uses to make requests to an API. The access token is meant to be read and validated by the API.

To validate the token on the backend side you can use the `validateOAuth2AccessToken` exposed by the `OAuth2Provider` recipe.

#### ID Token

An ID token contains information about what happened when a user authenticated, and is intended to be read by the **OAuth Client**.
The ID token may also contain information about the user such as their name or email address, although that is not a requirement of an ID token.

#### Refresh Token

An OAuth Refresh Token is a string that the OAuth client can use to get a new access token without the user's interaction.

### Flows

**Flows** are the set of steps an **OAuth Client** has to perform in order to obtain an access token.
Our implementation supports the following flow types:
- [Authorization Code](https://datatracker.ietf.org/doc/html/rfc6749#section-1.3.1)
- [Implicit](https://datatracker.ietf.org/doc/html/rfc6749#section-1.3.2)
- [Client credentials](https://datatracker.ietf.org/doc/html/rfc6749#section-1.3.4)
 

### Redirect URIs

In the *Authorization Code* and *Implicit* flows, the user is redirected to the authorization provider at the start of authentication.
The results are then communicated to the client through a redirection to one of the redirect URIs registered by the client.

These are configured on the client, during creation, or they can also be added later.
At the end of the authentication flow the user is redirected to one of these after they have completed the authorization request.

### Scopes

**Scopes** in OAuth 2.0 specify the level of access an application is requesting from the user's resources.
This way you can define the boundaries and permissions for what the access token can do.

:::note
- Where do we add these scopes in the actual code
- What's user-info
:::

Our implementation has the following built-in scopes:
- `email`: adds the `email` and `email_verified` claims into the id-token and the user-info.
- `phoneNumber`: adds the `phoneNumber` and `phoneNumber_verified` claims into the id-token and the user-info
- `roles`: adds the roles claim into the id-token and access token.
   - This will contain the roles returned by `getRolesForUser`
   - This only works if the `UserRoles` recipe is initialized
- `permissions`: adds the `permissions` claim into the id-token and access token.
   - This will contain the list of permissions obtained by concatenating the result of `getPermissionsForRole` for all roles returned by `getRolesForUser`
   - This only works if the `UserRoles` recipe is initialized


### PKCE

[**PKCE**](https://oauth.net/2/pkce/) is an extension to the **Authorization Code flow** to prevent CSRF and authorization code injection attacks. 
We support PKCE and recommend that you use a library that makes use of it. 
You can opt-in by setting the `code_challenge` (and optionally `code_challenge_method`) parameters in the authorization URL and then verifying it after the user gets redirected back to the client.

