---
title: Introduction 
hide_title: true
---

# OAuth2 Support 

**OAuth2**, Open Authorization, is an industry-standard authorization framework that enables third-party applications to obtain limited access to a user's resources without exposing their credentials.


## When to use OAuth2

In most cases, when using **SuperTokens**, you should not have to use **OAuth2** directly.
We already expose the **[ThirdParty Recipe](/docs/thirdparty/introduction)** that enables users to login using external providers. 
This covers most of the authentication scenarios that involve OAuth2. 

However, there are some custom use cases where you will have to implement a different authentication flow.

- **[If you have multiple frontend clients that connect to different backends](/docs/oauth/multiple-frontends-with-separate-backends)**
- **[If you have multiple frontend clients connecting to the same backend](/docs/oauth/multiple-frontends-with-a-single-backend)**
- **[If you want to have an unified login experience across multiple independent applications](/docs/oauth/clients-without-dedicated-backend)**
- **[If you want to reuse your website login for desktop and mobile apps](/docs/oauth/reuse-website-login)**
- **[For authenticating microservices](/docs/oauth/machine-to-machine-authentication)**

For these specific instances we expose recipes that allow you to complete your setup. 

:::caution
The **OAuth2 recipes** are available only when using the **SuperTokens Managed Service**. This feature is not included in the **Self-Hosted** version.

Also, the feature at the moment is supported, on the backend, just by the following **SDKs**:
- `supertokens-node`
- All our frontend SDKs

Additionally, our **OAuth2** implementation does not support magic links based login flows right now.
:::

Before we explore the guides let's first recap some common terms and concepts that are the base of the framework.
We will use them throughout the next pages.

## OAuth2 Roles

In OAuth, roles define the different responsibilities of entities involved in the process of granting and obtaining access to protected resources.
There are four roles defined in the specification:

### Resource Owner

The **Resource Owner** is an entity capable of granting access to a protected resource.
In most cases, this is an actual person that uses an application.

### Client

An **OAuth 2.0 Client** is an application that wants to access protected resources.
In order to do so it needs to get an [**Access Token**](#access-token) from the [**Authorization Server**](#authorization-server). 
With that token the client can perform authorized operations on behalf of the [**Resource Owner**](#resource-owner).

The term **client** does not imply any particular implementation characteristics (e.g. whether the application executes on a server, a desktop, or other devices).

### Resource Server

The server hosting the protected resources, capable of accepting and responding to protected resource requests using [**Access Tokens**](#access-tokens).
Some real-world examples in this case would be things like:
- A file storage service that allows users to access only their files
- A social media application that allows users to access only posts from their friends
- A chat app that shows only messages from conversations in which the user is a participant

### Authorization Server

The server issuing [**Access Tokens**](#access-tokens) to the [**Client**](#client) after successfully authenticating the [**Resource Owner**](#resource-owner).

## Tokens

Tokens are strings that represent the authorization issued to the [**Client**](#client).
They are mainly used to access to protected resources, on behalf of the [**Resource Owner**](#resource-owner).
At the same time, tokens can be used to have more information about who the owner is.

:::info

The tokens that are issued and used in the **OAuth 2.0** recipes are different from the ones used in our other features.
Normally, we work with **SuperTokens Session Acccess Tokens** to identify and authenticate the user.
But, in the case of **OAuth 2.0**, we expose **OAuth2 Tokens** that allow you create custom implementations.  

In all the **OAuth 2.0** pages and guides, when we talk about **tokens** we are referring to the **OAuth2 Tokens**.

:::

### Access Token

This is the main token that is used to provide temporary access to protected resources.
The **Access Token** is meant to be read and validated only by the [**Resource Server**](#resource-server).

#### Authorization Code

An **Authorization Code** is a short-lived code that the [**Authorization Server**](/#authorization-server) provides to the [**Client**](/#client), via the [**Redirect URI**](#redirect-uri), after authorization has been granted.
This code then gets exchanged for an [**Access Token**](/#access-token). 
The **Authorization Code** flow enhances security by keeping tokens out of the user-agent and letting the [**Client**](/#client) manage the backend communication with the [**Authorization Server**](/#authorization-server).

#### Redirect URI

A specific URI to which the [**Authorization Server**](/#authorization-server) redirects the [**Resource Owner's**](/#resource-owner) user-agent (e.g. browser) after the [**Client**](/#client) has been granted or denied the authorization request.
This URI ensures that the [**Authorization Code**](/#authorization-code) or [**Access Token**](/#access-token) is sent to the correct application endpoint.

### Refresh Token

A token that can be used to get a new [**Access Token**](#access-token) when the current one has expired.
Using the refresh token will not require the user to re-authenticate.

### ID Token

This token provides identity information about the [**Resource Owner**](#resource-owner).
Unlike [**Access Tokens**](/#access-token), the **ID Tokens** are meant to be read only by the [**Client**](#client).

## Scopes

Scopes define the range of access that the [**Client**](#client) is requesting on behalf of the [**Resource Owner**](#resource-owner).
They specify what portions of the **Resource Owner’s** data the **Client** can access and what actions it can perform.

For example, when a user grants a web application permission to read their email, the application might request the `email.read` scope.

In a general authentication flow scopes get used in the following way:
1. When the **Client** gets created a series of scopes will be specified to the **Authorization Server**
2. During the login attempt the **Resource Owner** will be asked to grant the requested scopes
3. The **Autorization Server** will use the granted scopes to generate an **Access Token**.
4. The **Resource Server** will check the scopes of the **Access Token** and will only allow the requested actions.



## Authorization Flows

The **OAuth 2.0** protocol defines several *flows* to accommodate different use cases.
They are a set of steps an **OAuth Client** has to perform in order to obtain an access token.

Our implementation supports the following flow types:

### [Authorization Code Grant](https://oauth.net/2/grant-types/authorization-code/)

<img src="/img/botandspamdetection/sequence-diagram.png" alt="Authorization Code Grant"/>

This flow is best suited for **web applications** where the [**Client**](/#client) can securely store a client secret (for example in the application's backend).
It consists of the following steps:
1. The **Client** redirects the **Resource Owner** to the **Authorization Server’s** authorization endpoint.
2. The **Authorization Server** authenticates the **Resource Owner** and requests their consent for the requested permissions.
3. If the **Resource Owner** grants permission, the **Authorization Server** redirects their browser back to the specified **Redirect URI** and includes an **Authorization Code** as a query parameter.
4. The **Client** then sends a request to the **Authorization Server**’s token endpoint, including the **Authorization Code**.
5. The **Authorization Server** verifies the information sent by the **Client** and, if valid, issues an **Access Token**.
6. The token can now be used to make requests to the **Resource Server** to access the protected resources on behalf of the **Resource Owner**. 

#### Proof Key for Code Exchange (PKCE)

If the **Client** has no backend server and it cannot securely store a client secret, it can use the **Authorization Code flow** with [**PKCE**](https://oauth.net/2/pkce/).
The **PKCE** extension prevents CSRF and authorization code injection attacks. 

At the beginning of the authentication flow the **Client** will generate a random string called a *code verifier*.
This gets used to ensure that, even if the **Authorization Code** is intercepted, it cannot be exchanged for a token without also including the initial code.


### [Client Credentials](https://oauth.net/2/grant-types/client-credentials/)

<img src="/img/botandspamdetection/sequence-diagram.png" alt="Client Credentials Grant"/>

This flow is best suited for **machine-to-machine** (M2M) interactions where there is no end-user.
It consists of the following steps:
1. The **Client** authenticates with the **Authorization Server** using its own credentials.
2. The **Authorization Server** verifies the credentials and issues an **Access Token**.
3. The **Client** uses the **Access Token** to access protected resources.




