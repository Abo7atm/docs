---
title: Introduction 
hide_title: true
---

# OAuth2 Support 

**OAuth2**, Open Authorization, is an industry-standard authorization framework that enables third-party applications to obtain limited access to a user's resources without exposing their credentials.


## When to use OAuth2

In most cases, when using **SuperTokens**, you should not have to use **OAuth2** directly.
We already expose the **[ThirdParty Recipe](/docs/thirdparty/introduction)** that enables users to login using external providers. 
This covers most of the authentication scenarios that involve OAuth2. 

However, there are some custom use cases where you will have to implement a different authentication flow.

- **[If you have multiple frontend clients that connect to different backends](/docs/oauth/multiple-frontends-with-separate-backends)**
- **[If you have multiple frontend clients connecting to the same backend](/docs/oauth/multiple-frontends-with-a-single-backend)**
- **[If you want to have an unified login experience across multiple independent applications](/docs/oauth/clients-without-dedicated-backend)**
- **[If you want to reuse your website login for desktop and mobile apps](/docs/oauth/reuse-website-login)**
- **[For authenticating microservices](/docs/oauth/machine-to-machine-authentication)**

For these specific instances we expose recipes that allow you to complete your setup. 

:::info
The **OAuth2 recipes** are available only when using the **SuperTokens Managed Service**. This feature is not included in the **Self-Hosted** version.

Also, the feature at the moment is supported just by the following **SDKs**:
- `supertokens-node`
- `supertokens-auth-react`

Additionally, our **OAuth2** implementation does not support magic links based login flows right now.
:::

## OAuth2 Reference

Before we explore the guides let's first recap some common terms and concepts that are the base of the framework.
We will use them throughout the next pages.

### Key Terms

#### Resource Owner

The **Resource Owner** is an entity capable of granting access to a protected resource.
When the resource owner is a person, it is referred to as an **end-user**.

#### Resource Server

The server hosting the protected resources, capable of accepting and responding to protected resource requests using **Access Tokens**.

#### Authorization Server

The server issuing access tokens to the **Client** after successfully authenticating the [**Resource Owner**](#resource-owner) and obtaining authorization

#### Client

An **OAuth 2.0 Client** is an application that interacts with an **OAuth 2.0 Provider** to request access to a user's resources. 
It then utilizes the access tokens granted by the provider to perform authorized operations on behalf of the [**Resource Owner**](#resource-owner).

The term **client** does not imply any particular implementation characteristics (e.g. whether the application executes on a server, a desktop, or other devices).

##### Provider

An **OAuth 2.0 Provider** is a server that implements the **OAuth 2.0** protocol, responsible for issuing access tokens to third-party applications after authenticating users.
The provider typically combines the functionality of both the [**Authorization Server**](/#authorization-server) and the [**Resource Server**](/#resource-server).
It defines the endpoints and mechanisms for token issuance and validation, and ensures secure, scalable interactions between [**Clients**](/#client), [**Resource Owners**](/#resource-owner), and [**Resource Servers**](/#authorization).

#### Access Token

A token issued by the [**Authorization Server**](/#authorization-server), that then gets passed by the [**Client**](/#client) to the [**Resource Server**](/#resource-server) to gain access to protected resources.
The access token is meant to be read and validated only by the **Resource Server**.

#### Refresh Token

An **OAuth Refresh Token** is a string that the [**OAuth Client** can use to get a new [**Access Token**](#access-token) when the current one has expired.
Using the refresh token will not require the user to re-authenticate.

#### OpenID Connect (OIDC)

**OpenID Connect (OIDC)** is an identity layer built on top of the **OAuth 2.0** protocol.
It allows clients to verify the identity of the end-user based on the authentication performed by an [**Authorization Server**](/#authorization-server), as well as obtain basic profile information about the end-user in an interoperable manner.
**OIDC** extends **OAuth 2.0** by defining additional standard scopes, endpoints, authentication mechanisms, and response types, making it easier to provide user authentication in a standardized way.

It also introduces a new type of token called **ID Token**.
This token gets issued by the [**Authorization Server**](/#authorization-server). 
It contains user profile information such as the user’s identity, the token’s issuance time, and its expiration time.
Unlike [**Access Tokens**](/#access-token), the **ID Token** is specifically used for authentication purposes (to verify the user's identity). 

#### Scopes

**Scopes** are permissions granted by the [**Resource Owner**](#resource-owner) to the [**Client**](#client).
For example, access only to read user emails or full access to user data.

#### Redirect URIs

A specific URI to which the [**Authorization Server**](/#authorization-server) redirects the [**Resource Owner's**](/#resource-owner) user-agent (e.g. browser) after the [**Client**](/#client) has been granted or denied the authorization request.
This URI ensures that the [**Authorization Code**](/#authorization-code) or [**Access Token**](/#access-token) is sent to the correct application endpoint.

Redirect URIs are used only in some of the **OAuth 2.0** flows. We will discuss them in detail below.

#### Authorization Code

An **Authorization Code** is a short-lived code that the [**Authorization Server**](/#authorization-server) provides to the [**Client**](/#client) via the [**Redirect URI**](#redirect-uri) after authorization has been granted.
This code then gets exchanged for an [**Access Token**](/#access-token). 
The **Authorization Code** flow enhances security by keeping tokens out of the user-agent and letting the [**Client**](/#client) manage the backend communication with the [**Authorization Server**](/#authorization-server).

### Authorization Flows

The **OAuth 2.0** protocol defines several *flows* to accommodate different use cases.
They are a set of steps an **OAuth Client** has to perform in order to obtain an access token.

Our implementation supports the following flow types:

- [Authorization Code Grant](https://oauth.net/2/grant-types/authorization-code/): This flow it is best suited for **web applications** where the [**Client**](/#client) can securely store a client secret. It consists of the following steps:
  - Client redirects the Resource Owner to the Authorization Server.
  - Resource Owner approves the request and is redirected back to the Client with an authorization code.
  - Client exchanges the authorization code for an access token at the Authorization Server.
  - Access token is used to access resources on the Resource Server.

- [Implicit](https://oauth.net/2/grant-types/implicit/): This flow is best suited for **public clients** like single-page applications (SPAs) without a backend server. It consists of the following steps:
  - Client redirects the Resource Owner to the Authorization Server.
  - Resource Owner approves the request and is redirected back to the Client with an access token.
  - Access token is used to access resources.

- [Client credentials](https://oauth.net/2/grant-types/client-credentials/): This flow is best suited for **machine-to-machine** (M2M) interactions where there is no end-user.
  - Client authenticates with the Authorization Server using its own credentials.
  - Authorization Server issues an access token to the Client.
  - Access token is used to access resources.

#### PKCE

[**PKCE**](https://oauth.net/2/pkce/) is an extension to the **Authorization Code flow** to prevent CSRF and authorization code injection attacks. 
We support PKCE and recommend that you use a library that can allow it. 



