---
title: Machine to Machine Authentication
hide_title: true
---

import BackendSDKTabs from "/src/components/tabs/BackendSDKTabs"
import TabItem from '@theme/TabItem';
import AppInfoForm from "/src/components/appInfoForm"
import CoreInjector from "/src/components/coreInjector"

# Machine to Machine Authentication

You can use the following guide if you want to implement a custom authentication flow between your microservices.

:::info
This guide assumes that you already have setup and configured **SuperTokens** in your [**Authentication Service**](/docs/oauth/introduction#authentication-service). 

For more information on how to do that please check our [quickstart guide](/docs/thirdparty/introduction).
:::


## 1. Create the OAuth2 Clients

For each of your **`microservices`** you will have to create a separate [**OAuth2 client**](/docs/oauth/introduction#client).
This can be done by directly calling the **SuperTokens Core** API.

<CoreInjector defaultValue="https://example.com">

```bash
curl -X POST ^{coreInjector_uri_without_quotes}/recipe/oauth2/admin/clients \
  -H "Content-Type: application/json" \
  -H "api-key: ^{coreInjector_api_key_without_quotes}" \
  -d '{
      "client_name": "<YOUR_CLIENT_NAME>",
      "grant_types": ["client_credentials"],
    }'
```

</CoreInjector>


- `client_name` - Then name of the client that will be used later for identification.
- `grant_types` - The grant types that the [**Client**](/#authorization) will use. 
    - `client_credentials`: Allows the client to directly request an Access Token by authenticating itself with the Authorization Server using its own client credentials.

If the creation was successful, the response will return a `201` status code.
The response body will contain a **`client_id`** field which you will need to use in the next steps.

## 2. Initialize the OAuth2Provider recipe 


In your **`authentication server`** you will need to initialize the **OAuth2Provider** recipe.
The recipe will expose the endpoints needed for enabling the [**OAuth 2.0**](/docs/oauth/introduction#oauth-20) flow.

<BackendSDKTabs>
<TabItem value="nodejs">

```typescript
import supertokens from "supertokens-node";
import OAuth2Provider from"supertokens-node/recipe/oauth2provider";
import OAuth2Client from"supertokens-node/recipe/oauth2client";

supertokens.init({
    framework: "express",
    supertokens: {
        connectionURI: "<YOUR_CONNECTION_URI>",
        apiKey: "<YOUR_API_KEY>",
    },
    appInfo: {
        appName: "",
        apiDomain: "<YOUR_API_DOMAIN>",
        websiteDomain: "<YOUR_WEBSITE_DOMAIN>",
        apiBasePath: "/auth",
        websiteBasePath: "/auth"
    },
    recipeList: [
        OAuth2Provider.init(),
    ]
});
```

</TabItem>

<TabItem value="go">

:::caution

At the moment we do not have support creating OAuth2 providers in the Go SDK.

:::

</TabItem>

<TabItem value="python">

:::caution

At the moment we do not have support creating OAuth2 providers in the Python SDK.

:::

</TabItem>

</BackendSDKTabs>


## 3. Generate Access Tokens

Now you can directly call the [**Authorization Server**](/docs/oauth/introduction#authorization-server) to generate Access Tokens.
Check the following code snippet to see how you can do that:

<AppInfoForm
    askForAppName={false}
    askForAPIDomain
    askForWebsiteDomain={false}
>

```bash

curl -X POST ^{form_apiDomain}^{form_apiBasePath}/oauth/token \
-H "Content-Type: application/json" \
-d '{
  "client_id": "<YOUR_CLIENT_ID>",
  "client_secret": "<YOUR_CLIENT_SECRET>",
  "grant_type": "client_credentials",
  "scope": ["<YOUR_REQUIRED_SCOPE>"]
}'

```

</AppInfoForm>

The **Authorization Server** will return a response that will look like this:

```json
{
    "access_token": "<TOKEN_VALUE>",
    "expires_in": 3600
}
```

You will have to save the `access_token` in memory so that you can use it in the next step.
The `expires_in` field will tell you how long the token is valid for.

## 4. Use the Generated Access Token 

Now that you have an **Access Token** you can use it when communicating with the other services.
Just keep in mind to generate a new one when it expires.

The service that will receive the request which includes the **Access Token** will have to verify it.
To see a detailed example of how to do this please check our [separate guide](/docs/oauth/customizations/verfiy-tokens).
