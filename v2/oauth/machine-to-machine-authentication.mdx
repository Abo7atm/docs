---
title: Machine to Machine Authentication
hide_title: true
---

import BackendSDKTabs from "/src/components/tabs/BackendSDKTabs"
import OAuthFrontendTabs from "/src/components/tabs/OAuthFrontendTabs"
import OAuthBackendTabs from "/src/components/tabs/OAuthBackendTabs"
import CoreInjector from "/src/components/coreInjector"
import AppInfoForm from "/src/components/appInfoForm"
import TabItem from '@theme/TabItem';

# Machine to Machine Authentication

You can use the following guide if you want to implement a custom authentication flow between your microservices.

<img src="/img/oauth/machine-to-machine.png" alt="Machine to Machine Authentication"/>

The authentication flow will work in the following way:

1. `Service A` uses credentials to get an **OAuth2 Access Token**
2. [**Authorization Service**](/docs/oauth/introduction#authorization-service) returns the **OAuth2 Access Token**
3. `Service A` uses the **OAuth2 Access Token** to communicate with `Service B`
4. `Service B` validates the **OAuth2 Access Token**
5. If the token is valid `Service B` returns the requested resource

:::info
This guide assumes that you already have setup and configured **SuperTokens** in your [**Authorization Service**](/docs/oauth/introduction#authorization-service). 

For more information on how to do that please check our [quickstart guide](/docs/thirdparty/introduction).
:::

<!-- COPY SECTION -->
<!-- ./oauth/multiple-frontends-with-separate-backends.mdx -->
<!-- 1 -->

## 1. Enable the OAuth2 features from the Dashboard

You will first have to enable the **OAuth2** features from the **SuperTokens.com Dashboard**.
1. Open the **SuperTokens.com Dashboard**
2. Click on the **Enabled Paid Features** button
3. Click on **Managed Service**
4. Check the **OAuth 2.0** option
5. Click *Save* 

Now you should be able to use the OAuth2 recipes in your applications.

<!-- END COPY SECTION -->

## 2. Create the OAuth2 Clients


<CoreInjector defaultValue="https://<your-core-identifier>.aws.supertokens.io" showTenantId={false}>


For each of your **`microservices`** you will have to create a separate [**OAuth2 client**](/docs/oauth/introduction#client).
This can be done by directly calling the **SuperTokens Core** API.

<AppInfoForm
    askForAppName
    askForAPIDomain
    askForWebsiteDomain
>
 


```bash
# You will have to run this for each one of your applications
# Adjust the client_name based on that
curl -X POST ^{coreInjector_uri_without_quotes}/recipe/oauth2/admin/clients \
  -H "Content-Type: application/json" \
  -H "api-key: ^{coreInjector_api_key_without_quotes}" \
  -d '{
      "clientName": "<YOUR_CLIENT_NAME>",
      "grantTypes": ["client_credentials"],
      "scope": "<custom_scope_1> <custom_scope_2>",
      "audience": ["<AUDIENCE_NAME>"]
    }'
```


- `clientName` - Then name of the client that will be used later for identification.
- `grantTypes` - The grant types that the [**Client**](/docs/oauth/introduction#client) will use. 
    - `clientCredentials`: Allows the client to directly request an Access Token by authenticating itself with the Authorization Server using its own client credentials.
- `audience` - Value used to identify for whom a token was issued. When a service will request an **OAuth2 Token** that can be used on this client, the requested token should include one of the audience values.
- `scope` -  A space separated string of scopes that the [**Client**](/docs/oauth/introduction#client) will request access to.

If the creation was successful, the API will return a response that looks like this:

```json
{
    "clientName": "<YOUR_CLIENT_NAME>",
    "clientId": "<CLIENT_ID>",
    "clientSecret": "<CLIENT_SECRET>",
    "callbackUrls": [],
}

```

Based on the client creation process we can also infer the `authorizationUrl` value which is `^{form_apiDomain}^{form_apiBasePath}oauth/auth`. We will use this later on.

### Change the default token lifespan

By default, the token used in the authorization flow will have a 1 hour lifespan.

If you want to change it you will need to set the `clientCredentialsGrantAccessTokenLifespan` property in the [**Client**](/docs/oauth/introduction#client) creation request body.
Use string values that signify time duration in milliecoseconds, seconds, minutes or hours (e.g. `"2000ms"`, `"60s"`, `"30m"`, `"1h"`).

Keep in mind to use short lived tokens so that they can be only used once in order to prevent security concerns. 

## 3. Set Up your Authorization Service 

In your [**Authorization Service**](/docs/oauth/introduction#authorization-service) backend you will need to initialize the **OAuth2Provider** recipe.

<BackendSDKTabs  disableOtherFrameworks>

<TabItem value="nodejs">

Update the `supertokens.init` call to include the new recipe.

Add the new import statement and update the list of recipes with the new initialization step.

```tsx

import supertokens from "supertokens-node";
import OAuth2Provider from "supertokens-node/recipe/oauth2provider";


supertokens.init({
    supertokens: {
        connectionURI: "...",
        apiKey: "...",
    },
    appInfo: {
        appName: "...",
        apiDomain: "...",
        websiteDomain: "...",
    },
    recipeList: [
      OAuth2Provider.init(),
    ]
});

```


</TabItem>

<TabItem value="go">

:::caution

At the moment we do not have support creating OAuth2 providers in the Go SDK.

:::

</TabItem>

<TabItem value="python">

:::caution

At the moment we do not have support creating OAuth2 providers in the Python SDK.

:::

</TabItem>

</BackendSDKTabs>


## 4. Generate Access Tokens

Now you can directly call the [**Authorization Server**](/docs/oauth/introduction#authorization-server) to generate Access Tokens.
Check the following code snippet to see how you can do that:


```bash

curl -X POST ^{form_apiDomain}^{form_apiBasePath}/oauth/token \
-H "Content-Type: application/json" \
-d '{
  "clientId": "<CLIENT_ID>",
  "clientSecret": "<CLIENT_SECRET>",
  "grantType": "client_credentials",
  "scope": ["<RESOURCE_SCOPE>"],
  "audience": "<AUDIENCE>"
}'

```

:::info

The scopes that you are requesting should be limited to just the ones needed to access a resource on the service that acts as a **Resource Server**.
Otherwise, if the scopes are too broad, the token could be used by the **Resource Server** to authenticate against other services in the network. 

:::

The **Authorization Server** will return a response that will look like this:

```json
{
    "accessToken": "<TOKEN_VALUE>",
    "expiresIn": 3600
}
```

You will have to save the `accessToken` in memory so that you can use it in the next step.
The `expiresIn` field will tell you how long the token is valid for.

Save this token in memory and use it to perform protected actions on the targeted service.
You will have to use a different token for each of the services that you want to communicate with.

## 5. Use the Generated Access Token 

Now that you have an **OAuth2 Access Token** you can use it when communicating with the other services.
Just keep in mind to generate a new one when it expires.

The service that will receive the request which includes the **OAuth2 Access Token** will have to verify it.
To see a detailed example of how to do this please check our [separate guide](/docs/oauth/customizations/verify-tokens).

</AppInfoForm>

</CoreInjector>
