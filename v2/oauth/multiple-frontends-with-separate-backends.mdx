---
title: Multiple frontend domains with separate backends
hide_title: true
---

import BackendSDKTabs from "/src/components/tabs/BackendSDKTabs"
import CoreInjector from "/src/components/coreInjector"

# Multiple frontend domains with separate backends

You can use the following guide if you have a single [**Authentication Service**](/docs/oauth/introduction#authentication-service) that is used by multiple applications.
In turn, each app has separate **`frontend `** and **`backend`** instances that are served from different domains.
Using the actual **OAuth 2.0** terminology, that each application can be considered a [**Client**](/docs/oauth/introduction#client) while the **`backends`** are also [**Resource Servers**](/docs/oauth/introduction#resource-server).

Note that if the *frontends* and *backends* are in different *sub domains*, you don't need to use *OAuth* and can instead use [session sharing across sub domains](/docs/session/common-customizations/sessions/share-sessions-across-sub-domains).

<img src="/img/botandspamdetection/sequence-diagram.png" alt="Client Credentials Grant"/>

:::info
This guide assumes that you already have setup and configured **SuperTokens** in your [**Authentication Service**](/docs/oauth/introduction#authentication-service). 

For more information on how to do that please check our [quickstart guides](/docs/guides).
:::

## 1. Enable the OAuth2 features from the Dashboard

You will first have to enable the **OAuth2** features from the **SuperTokens Dashboard**.
1. Open the **SuperTokens Dashboard** on the main page
2. Click on the **Enabled Paid Features** button
3. Click on **Managed Service**
4. Check the **OAuth 2.0** option
5. Click *Save* 

Now you should be able to use the OAuth2 recipes in your applications.

## 2. Create the OAuth2 Clients

For each of your **`frontend`** applications you will have to create a separate [**OAuth2 client**](/docs/oauth/introduction#client).
This can be done by directly calling the **SuperTokens Core** API.

<CoreInjector defaultValue="https://<your-core-identifier>.aws.supertokens.io" showTenantId={false}>

```bash
curl -X POST ^{coreInjector_uri_without_quotes}/recipe/oauth2/admin/clients \
  -H "Content-Type: application/json" \
  -H "api-key: ^{coreInjector_api_key_without_quotes}" \
  -d '{
      "client_name": "<YOUR_CLIENT_NAME>",
      "response_types": ["code", "id_token"],
      "grant_types": ["authorization_code", "refresh_token"],
      "redirect_uri": ["https://<YOUR_DOMAIN>/oauth/callback"]
    }'
```

</CoreInjector>


- `client_name` - A human-readable name of the client that will be presented to the [**end-user**](/docs/oauth/introduction#authorization) during authorization.
- `response_types` - Specifies the types of responses your client expects from the Authorization Server. Most of the time, you would need the following two to be present:
    - `code`: Indicates that the [**Client**](/#authorization) will receive an [**Authorization Code**](/#authorization) that will be exchanged for an [**Access Token**](/#authorization).
    - `id_token`: Indicates that the [**Client**](/#authorization) expects an [**ID Token**](/#authorization)
- `grant_types` - The grant types that the [**Client**](/#authorization) will use. 
    - `authorization_code`: Allows exchanging the [**Authorization Code**](/#authorization) for an [**Access Token**](/#authorization).
    - `refresh_token`: Allows exchanging the [**Refresh Token**](/#authorization) for a new [**Access Token**](/#authorization).
- `redirect_uri` - A list of URIs to which the [**Authorization Server**](/#authorization) will send the user-agent (browser) after completing the authorization step. These can be deep links to mobile or desktop apps as well, but they must be exact URLs, without wildcards.

If the creation was successful, the response will return a `201` status code.
The response body will contain the **`client_id`** and the `client_secret` fields. Save them for each request because we will need to use them in the next steps.

## 3. Initialize the OAuth2 Provider Recipe 

In your [**Authentication Service**](/docs/oauth/introduction#authentication-service) you will need to initialize the **OAuth2Provider** recipe.
The recipe will expose the endpoints needed for enabling the [**OAuth 2.0**](/docs/oauth/introduction#oauth-20) flow.


<BackendSDKTabs>
<TabItem value="nodejs">

```typescript
import supertokens from "supertokens-node";
import OAuth2Provider from"supertokens-node/recipe/oauth2provider";

supertokens.init({
    framework: "express",
    supertokens: {
        connectionURI: "<YOUR_CONNECTION_URI>",
        apiKey: "<YOUR_API_KEY>",
    },
    appInfo: {
        appName: "",
        apiDomain: "<YOUR_API_DOMAIN>",
        websiteDomain: "<YOUR_WEBSITE_DOMAIN>",
    },
    recipeList: [
        // This is where you initialize the OAuth2 recipe
        OAuth2Provider.init(),
    ]
});
```

</TabItem>

<TabItem value="go">

:::caution

At the moment we do not have support creating OAuth2 providers in the Go SDK.

:::

</TabItem>

<TabItem value="python">

:::caution

At the moment we do not have support creating OAuth2 providers in the Python SDK.

:::

</TabItem>

</BackendSDKTabs>


###  Configure the Authorization Service Frontend 

:::info

The `OAuth2Provider` recipe is available, at the moment, only when using the `supertokens-auth-react` package.

:::

Initialize the `OAuth2Provider` recipe on the frontend of your **Authorization Service**, ensuring you set the `authMode` to `header`.

```tsx
import OAuth2Provider from "supertokens-auth-react/recipe/oauth2provider";
import Session from "supertokens-auth-react/recipe/session";


export const SuperTokensConfig = {
    appInfo: {
        appName: "App Name",
        apiDomain: "<AUTHENTICATION_SERVICE_DOMAIN>",
        websiteDomain: "<FRONTEND_APPLICATION_DOMAIN>",
    },
    recipeList: [
        OAuth2Provider.init({ authMode: "header" }),
        Session.init(),
    ],
};

```

## 4. Set Up Session Handling in Each Application

In each of your `backend applications` you will have to setup up logic for handling the **OAuth 2.0** authentication flow.

This will involve the following steps:

:::note
What are the actual steps?
:::

The following steps are only required if you are using the **Session** recipe. If you are not using the **Session** recipe, you can skip this step.
1. Exposing an endpoint that can take the authorization code and exchange it for an access token
2. Verifying the access token on each request 

You can use a generic OIDC or OAuth2 library to achieve these steps.

<BackendSDKTabs>

<TabItem value="nodejs">

We recommend using either [passport-oauth2](https://www.passportjs.org/packages/passport-oauth2/) or [passport-openidconnect](https://www.passportjs.org/packages/passport-openidconnect/).

#### Example using `passport-oauth2`:


</TabItem>

<TabItem value="go">

</TabItem>


<TabItem value="python"> 

</TabItem>


</BackendSDKTabs>


## 5. Update the login flow in your frontend applications

In your `frontend applications` you will have to add a login action that will direct the user to the authentication page.
You can just use a link for that.

The link should be structured like this:

```
<AUTHENTICATION_SERIVICE_DOMAIN>/auth/oauth/auth?client_id=<CLIENT_ID>&redirect_uri=<REDIRECT_URI>&scope=<SCOPES>&state=<STATE>
```
- `<AUTHENTICATION_SERIVICE_DOMAIN>` - The domain of your [**Authentication Service**](/docs/oauth/introduction#authentication-service).
The example assumes that you didn't overwrite the default `apiBasePath`.
If that's the case you will have to replace `/auth` with you custom base path.
- `<CLIENT_ID>` - The corresponding client ID based on what you have created in the first step.
- `<REDIRECT_URI>` - The corresponding redirect URI based on what you have created in the first step.
- `<SCOPES>` - The scopes that you want to request. This is optional and can be left empty.
- `<STATE>` - A random string that will be used to prevent CSRF attacks. This is optional and can be left empty.

## 6. Test the new authentication flow

With everything set up, you can now test your login flow.
Just use the link that you have created in the previous step and try to access a protected resource.
