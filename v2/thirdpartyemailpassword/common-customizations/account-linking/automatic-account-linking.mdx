---
id: automatic-account-linking
title: Automatic account linking
hide_title: true
---

<!-- COPY DOCS -->
<!-- ./thirdpartyemailpassword/common-customizations/account-linking/automatic-account-linking.mdx -->

import MultiTenancyPaidBanner from '../../../community/reusableMD/multitenancy/MultiTenancyPaidBanner.mdx'
import BackendSDKTabs from "/src/components/tabs/BackendSDKTabs";

<MultiTenancyPaidBanner />

# Automatic account linking

Automatic account linking is a feature that allows users to automatically sign in to their existing account using more than one login method. On a high level, the accounts for the different login methods are linked automatically by SuperTokens provided that:
- Their emails or phone numbers are the same.
- Their emails or phone numbers are verified.

SuperTokens ensures that accounts are automatically linked only if there is [no risk of account takeover](./security-considerations).

## Enabling automatic account linking

You can enable this feature by providing the following callback implementation on the backend SDK:

<BackendSDKTabs>
<TabItem value="nodejs">

```tsx
import supertokens, { User } from "supertokens-node";
import AccountLinking from "supertokens-node/recipe/accountlinking";
import { AccountInfoWithRecipeId } from "supertokens-node/recipe/accountlinking/types";

supertokens.init({
    supertokens: {
        connectionURI: "<CONNECTION_URI_HERE_FROM_THE_POPUP>",
        apiKey: "<API_KEY_HERE_FROM_THE_POPUP>"
    },
    appInfo: {
        apiDomain: "...",
        appName: "...",
        websiteDomain: "..."
    },
    recipeList: [
        // highlight-start
        AccountLinking.init({
            shouldDoAutomaticAccountLinking: async (newAccountInfo: AccountInfoWithRecipeId, user: User | undefined, tenantId: string, userContext: any) => {
                return {
                    shouldAutomaticallyLink: true,
                    shouldRequireVerification: true
                }
            }
        })
        // highlight-end
    ]
});
```

</TabItem>
<TabItem value="go">

:::note
Coming Soon
:::

</TabItem>
<TabItem value="python">

:::note
Coming Soon
:::

</TabItem>
</BackendSDKTabs>

#### Input args meaning:
- `newAccountInfo: AccountInfoWithRecipeId`: This object contains information about the user whose account is going to be linked, or will become a primary user. The object contains the user's email, social login info and phone number (whichever they used to sign in / up with). It also contains the login method (`emailpassword`, `thirdparty`, or `passwordless`).
- `user: User | undefined`: If this is not `undefined`, it means that `newAccountInfo` user is about to linked to this `user`. If this is `undefined`, it means that `newAccountInfo` user is about to become a primary user.
- `tenant: string`: The ID of the tenant that the user is signing in / up to.
- `userContext: any`: User defined userContext.

#### Output args meaning:
- `shouldAutomaticallyLink`: If this is `true`, it means that the `newAccountInfo` will be linked or will become a primary user during this API call (assuming a set of security checks pass). If this is `false`, it means that there will be no account linking related operation during this API call.
- `shouldRequireVerification`: If this is `true`, that account linking operations will only happen if the `newAccountInfo` is verified. **We strongly recommend keeping it set to `true` for security reasons.**

You can use the input of the function to dynamically decide if you want to do account linking for a particular user and / or login method or not.

## Different scenarios of automatic account linking

- **During sign up**: If there exists another account with the same email or phone number within the current tenant, the new account will be linked to the existing account if:
    - The existing account is a primary user
    - If `shouldRequireVerification` is `true`, the new account needs to be created via a method that has the email as verified (for example via passwordless or google login). If the new method doesn't inherently verify the email (like in email password login), the the accounts will be linked post email verification.
    - Your implementation for `shouldDoAutomaticAccountLinking` returns `true` for the `shouldAutomaticallyLink` boolean.

- **During sign in**: If the current user is not already linked and if there exists another user with the same email or phone number within the current tenant, the accounts will be linked if:
    - The user being signed into is NOT a primary user, and the other user with the same email / phone number IS a primary user
    - If `shouldRequireVerification` is `true`, the current account (that's being signed into) has its email as verified.
    - Your implementation for `shouldDoAutomaticAccountLinking` returns `true` for the `shouldAutomaticallyLink` boolean.

- **After email verification**: If the current user whose email got verified is not a primary user, and there exists another primary user in the same tenant with the same email, then we link the two accounts if:
    - Your implementation for `shouldDoAutomaticAccountLinking` returns `true` for the `shouldAutomaticallyLink` boolean.

- **During password reset flow**: If there already exists a user with the same email in a non email password recipe (social login for example), and the user is doing a password reset flow, a new email password user is created and linked to the existing account if:
    - The non email password user is a primary user.
    - Your implementation for `shouldDoAutomaticAccountLinking` returns `true` for the `shouldAutomaticallyLink` boolean.

## Affect on email verification
For a primary user, if there exists two login method (L1 & L2), and they both have the same email, but the email for L1 is verified and not for L2, SupeTokens will auto verify the email for L2 when:
- The user next logs in with L2.
- If you call `updateEmailOrPassword` from the email password or `updateUser` from the passwordless recipe, updating L2's email to be equal to L1's email.

## Affect on email update
When updating the email of a login method for a user, SuperTokens needs to make sure that the account linking conditions mentioned above remain intact. This means that you cannot update the email of a primary user to a value that matches the email of another primary user. 

For example, if User A has login method `AL1` (email `e1`) and `AL2` (email `e1`), and User B has login method `BL1` (email `e2`) and `BL2` (email `e3`), then we cannot update `AL1` email to `e2` or `e3` because that would lead to two primary users having the same email.

Now email updates can happen in different scenarios:
- 1) Calling the `updateEmailOrPassword` from the email password recipe
- 2) Calling the `updateUser` function from the passwordless recipe
- 3) Logging in via social login can also update emails if the email has changed from the provider's side.

In each of these cases, the operation will fail and an appropriate status code will be returned:
- For function calls (1) and (2), you will get back a response with a status indicating that email update was not possible.
- For social login API call (3), the client will get a response with a status indicating to contact support, with a support status code (see below).

## Migration of user data when accounts are linked
TODO

## Support status codes
TODO

