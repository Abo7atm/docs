---
id: session-verification
title: 5. Session verification in an API call
hide_title: true
---

<!-- COPY DOCS -->
<!-- ./thirdpartyemailpassword/nextjs/app-directory/session-verification.mdx -->

# 5. Session verification in an API call

:::note
This is applicable for when the frontend calls an API in the `/app/api` folder.
:::

For this guide, we will assume that we want an API `/api/user GET` which returns the current session information.

## 1) Create new helper functions

We will create some functions so that we can use them to check for sessions in our APIs

```ts
import { cookies, headers } from 'next/headers';
import { NextRequest, NextResponse } from 'next/server';
import Session, { SessionContainer } from 'supertokens-node/recipe/session';
import { ensureSuperTokensInit } from './config/backend';

ensureSuperTokensInit();

export async function getSSRSession(req?: NextRequest): Promise<{
  session: SessionContainer | undefined;
  hasToken: boolean;
  resp?: Response;
}> {
  let token;
  if (req?.cookies) {
    token = req.cookies.get('sAccessToken')?.value;
  } else {
    token = cookies().get('sAccessToken')?.value;
  }

  if (req?.headers.get("Authorization")) {
    token = req.headers.get("Authorization")!;
    // We remove the "Bearer" from the token
    if (token.includes("Bearer")) {
      token = token.replace("Bearer ", "");
    }
  }

  if (token === undefined) {
    return {
      session: undefined,
      hasToken: false,
      resp: new NextResponse('Authentication required', { status: 401 }),
    };
  }

  let session;
  let resp;

  try {
    session = await Session.getSessionWithoutRequestResponse(token, undefined, {
      sessionRequired: false,
    });
  } catch (err) {
    if (Session.Error.isErrorFromSuperTokens(err)) {
      resp = new NextResponse('Authentication required', {
        status: err.type === Session.Error.INVALID_CLAIMS ? 403 : 401,
      });
    } else {
      throw err;
    }
  }

  return {
    session,
    hasToken: true,
    resp,
  };
}

export function updateSessionInResponse(
    session: SessionContainer,
    response?: NextResponse,
  ) {
    let tokens = session.getAllSessionTokensDangerously();
    if (tokens.accessAndFrontTokenUpdated) {
      const accessTokenCookie = {
        name: 'sAccessToken',
        value: tokens.accessToken,
        httpOnly: true,
        path: '/',
        expires: Date.now() + 3153600000000,
      };
  
      if (response) {
        response.cookies.set(accessTokenCookie);
        response.headers.set('front-token', tokens.frontToken);
      } else {
        cookies().set(accessTokenCookie);
        headers().set('front-token', tokens.frontToken);
      }
    }
  }

export async function withSession(
    request: NextRequest,
    handler: (session: SessionContainer | undefined) => Promise<NextResponse>,
  ) {
    let { session, resp: stResponse } = await getSSRSession(request);
    if (stResponse) {
        return stResponse;
    }
    let userResponse = await handler(session);

    if (session) {
        updateSessionInResponse(session, userResponse);
    }
    return userResponse;
}
```

The `getSSRSession` is a function we created in a previous step. The `withSession` function will be used in our APIs to check if a session exists, it will call the callback which is where our API logic will be written. `updateSessionInResponse` helps with attaching session tokens to the response.

## 2) Create a new file `/app/api/user/route.ts`
- An example of this is [here](https://github.com/supertokens/next.js/blob/canary/examples/with-supertokens/app/api/user/route.ts).

```ts
import { NextResponse, NextRequest } from 'next/server';
import { withSession } from '../../sessionUtils';
import SuperTokens from 'supertokens-node';

export function GET(request: NextRequest) {
  return withSession(request, async (session) => {
    if (!session) {
      return new NextResponse('Authentication required', { status: 401 });
    }

    const userId = session.getUserId();
    const user = await SuperTokens.getUser(userId);
    
    if (user === undefined) {
        return NextResponse.json({
            email: "not found",
        })
    }

    return NextResponse.json({
      email: user.emails[0],
    });
  })
}
```

In the above snippet we are creating a `GET` handler for the `/api/user` route. We call the `withSession` helper function we created above, the function will pass the session object in the callback which we then use to read user information. If a session does not exist `undefined` will be passed intead.

## 3) Calling the API from the frontend

Lets modify the Home page we made in a previous step to make a call to this API

```tsx title="app/components/home.tsx"
import { getSSRSession } from '../sessionUtils';
import { TryRefreshComponent } from './tryRefreshClientComponent';
import styles from '../page.module.css';
import { redirect } from 'next/navigation'
import { SignOut } from './signOut';

export async function HomePage() {
  const { session, hasToken } = await getSSRSession();

  if (!session) {
    if (!hasToken) {
      redirect('/auth');
    }
    return <TryRefreshComponent />;
  }

  const userEmailResponse = await fetch('http://localhost:3000/api/user', {
    headers: {
      Authorization: 'Bearer ' + session.getAccessToken(),
    },
  });

  let email = "";

  if (userEmailResponse.status !== 200) {
    email = "error with status " + userEmailResponse.status;
  } else {
    email = (await userEmailResponse.json()).email;
  }

  return (
    <div>
        <div>
            <p className={styles.description}>
            Server side component got userId: {session.getUserId()}<br/>
            Server side component got email: {email}
            </p>
        </div>
        <SignOut/>
    </div>
  );
}
```

We use `session` returned by `getSSRSession` to get the access token of the user. We can then send the access token as a header to the API. When the API calls `withSession` it will try to read the access token from the headers and if a session exists it will return the information. You can use the `session` object to fetch other information such as `session.getUserId()`.

## (OPTIONAL) Using the Next.js middleware

:::warning
We do not recommend this approach because information set by the middleware will not change based on changes in the user session
:::

```tsx title="middleware.tsx"
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'
import { SessionContainer } from 'supertokens-node/recipe/session'
import { withSession } from './app/sessionUtils';


export async function middleware(
  request: NextRequest & { session?: SessionContainer }
) {
  if (request.headers.has("x-user-id")) {
    console.warn("The FE tried to pass x-user-id, which is only supposed to be a backend internal header. Ignoring.");
    request.headers.delete("x-user-id");
  }

  if (request.nextUrl.pathname.startsWith('/api/auth')) {
    // this hits our pages/api/auth/* endpoints
    return NextResponse.next()
  }

  return withSession(request, async (session) => {
    if (session === undefined) {
      return NextResponse.next()
    }
    return NextResponse.next({
      headers: {
        'x-user-id': session.getUserId(),
      },
    })
  })
}

export const config = {
  matcher: '/api/:path*',
}
```

In the middleware we check if a session exists using the `withSession` helper function and set the user's user id to the request headers using the session object. You can set other information in the same way.

:::note
You cannot attach the full request object to the request
:::