---
id: frontend
title: "Step 1: Frontend"
hide_title: true
---

import FrontendCustomUITabs from "/src/components/tabs/FrontendCustomUITabs"
import FrontendMobileSubTabs from "/src/components/tabs/FrontendMobileSubTabs"
import TabItem from '@theme/TabItem';
import {Question, Answer}from "/src/components/question"
import AppInfoForm from "/src/components/appInfoForm"
import NpmOrScriptTabs from "/src/components/tabs/NpmOrScriptTabs"
import WebJsInjector from "/src/components/webJsInjector"

# Create Your Own Custom UI

## Overview 

This quickstart will guide you through how to use the **SuperTokens Frontend SDK** to build your own custom UI.

:::info
This tutorial assumes that you already have **SuperTokens** configured and working in your backend.
If you have skipped this step please check the [main quickstart](./quickstart) guide for instructions on how to do this.
:::


## 1. Install the SDK

Use the following command to install the required package.

<FrontendCustomUITabs>
<TabItem value="web">

<NpmOrScriptTabs>
<TabItem value="npm">

```bash
npm i -s supertokens-web-js
```

</TabItem>
<TabItem value="script">

You need to add all of the following scripts to your app

<WebJsInjector>

```bash
<script src="^{jsdeliver_webjs_website}"></script>
<script src="^{jsdeliver_webjs_supertokens}"></script>
<script src="^{jsdeliver_webjs_session}"></script>
<script src="^{jsdeliver_webjs_^{codeImportRecipeName}}"></script>
```

</WebJsInjector>

</TabItem>
</NpmOrScriptTabs>

</TabItem>

<TabItem value="mobile">

:::info

If you want to implement a common authencation experience for both web and mobile, please look at our [**Unified Login guide**](/docs/unified-login/introduction).

:::

<FrontendMobileSubTabs>

<TabItem value="reactnative">

```bash
npm i -s supertokens-react-native
# IMPORTANT: If you already have @react-native-async-storage/async-storage as a dependency, make sure the version is 1.12.1 or higher
npm i -s @react-native-async-storage/async-storage
```

</TabItem>

<TabItem value="android">

Add to your `settings.gradle`:
```bash
dependencyResolutionManagement {
    ...
    repositories {
        ...
        maven { url 'https://jitpack.io' }
    }
}
```

Add the following to you app level's `build.gradle`:
```bash
implementation 'com.github.supertokens:supertokens-android:X.Y.Z'
```

You can find the latest version of the SDK [here](https://github.com/supertokens/supertokens-android/releases) (ignore the `v` prefix in the releases).

</TabItem>

<TabItem value="ios">

#### Using Cocoapods

Add the Cocoapod dependency to your Podfile

```bash
pod 'SuperTokensIOS'
```

#### Using Swift Package Manager

Follow the [official documentation](https://developer.apple.com/documentation/xcode/adding-package-dependencies-to-your-app) to learn how to use Swift Package Manager to add dependencies to your project.

When adding the dependency use the `master` branch after you enter the supertokens-ios repository URL:

```bash
https://github.com/supertokens/supertokens-ios
```

</TabItem>

<TabItem value="flutter">

Add the dependency to your pubspec.yaml

```bash
supertokens_flutter: ^X.Y.Z
```

You can find the latest version of the SDK [here](https://github.com/supertokens/supertokens-flutter/releases) (ignore the `v` prefix in the releases).

</TabItem>

</FrontendMobileSubTabs>

</TabItem>

</FrontendCustomUITabs>

## 2. Initialize the SDK

<FrontendCustomUITabs>
<TabItem value="web">

<NpmOrScriptTabs>
<TabItem value="npm">

<AppInfoForm askForAPIDomain>

Call the following `init` function at the start of your app (ideally on the global scope).

```tsx
import SuperTokens from 'supertokens-web-js';
import Session from 'supertokens-web-js/recipe/session';
import ^{recipeNameCapitalLetters} from 'supertokens-web-js/recipe/^{codeImportRecipeName}'

SuperTokens.init({
    appInfo: {
        apiDomain: "^{form_apiDomain}",
        apiBasePath: "^{form_apiBasePath}",
        appName: "...",
    },
    recipeList: [
        Session.init(),
        ^{recipeNameCapitalLetters}.init(),
    ],
});
```

</AppInfoForm>

</TabItem>
<TabItem value="script">

<AppInfoForm askForAPIDomain>

Call the following `init` function at the start of your app (ideally on the global scope).

```tsx
import supertokens from "supertokens-web-js-script";
import supertokensSession from "supertokens-web-js-script/recipe/session";
import supertokens^{recipeNameCapitalLetters} from 'supertokens-web-js-script/recipe/^{codeImportRecipeName}'
supertokens.init({
    appInfo: {
        apiDomain: "^{form_apiDomain}",
        apiBasePath: "^{form_apiBasePath}",
        appName: "...",
    },
    recipeList: [
        supertokensSession.init(),
        supertokens^{recipeNameCapitalLetters}.init(),
    ],
});
```

</AppInfoForm>

</TabItem>
</NpmOrScriptTabs>

</TabItem>

<TabItem value="mobile">

<FrontendMobileSubTabs>

<TabItem value="reactnative">

<AppInfoForm askForAPIDomain>

Call the following `init` function at the start of your app (ideally on the global scope).

```tsx
import SuperTokens from 'supertokens-react-native';

SuperTokens.init({
    apiDomain: "^{form_apiDomain}",
    apiBasePath: "^{form_apiBasePath}",
});
```

</AppInfoForm>

</TabItem>

<TabItem value="android">

<AppInfoForm askForAPIDomain>

Add the `SuperTokens.init` function call at the start of your application.

```kotlin
import android.app.Application
import com.supertokens.session.SuperTokens

class MainApplication: Application() {
    override fun onCreate() {
        super.onCreate()
        
        SuperTokens.Builder(this, "^{form_apiDomain}")
            .apiBasePath("^{form_apiBasePath}")
            .build()
    }
}
```

</AppInfoForm>

</TabItem>

<TabItem value="ios">

<AppInfoForm askForAPIDomain>

Add the `SuperTokens.initialize` function call at the start of your application.

```swift
import UIKit
import SuperTokensIOS

fileprivate class ApplicationDelegate: UIResponder, UIApplicationDelegate {
    
    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
        do {
            try SuperTokens.initialize(
                apiDomain: "^{form_apiDomain}",
                apiBasePath: "^{form_apiBasePath}"
            )
        } catch SuperTokensError.initError(let message) {
            // TODO: Handle initialization error
        } catch {
            // Some other error
        }

        return true
    }
    
}
```

</AppInfoForm>

</TabItem>

<TabItem value="flutter">

<AppInfoForm askForAPIDomain>

Add the `SuperTokens.init` function call at the start of your application.

```dart
import 'package:supertokens_flutter/supertokens.dart';

void main() {
    SuperTokens.init(
        apiDomain: "^{form_apiDomain}",
        apiBasePath: "^{form_apiBasePath}",
    );
}
```

</AppInfoForm>

</TabItem>

</FrontendMobileSubTabs>

</TabItem>

</FrontendCustomUITabs>


## 3. Add the Sign Up form

<FrontendCustomUITabs>
<TabItem value="web">

Call the following function when the user clicks on the sign up button.

<NpmOrScriptTabs>
<TabItem value="npm">

```tsx
import { signUp } from "supertokens-web-js/recipe/emailpassword";

async function signUpClicked(email: string, password: string) {
    try {
        let response = await signUp({
            formFields: [{
                id: "email",
                value: email
            }, {
                id: "password",
                value: password
            }]
        })

        if (response.status === "FIELD_ERROR") {
            // one of the input formFields failed validation
            response.formFields.forEach(formField => {
                if (formField.id === "email") {
                    // Email validation failed (for example incorrect email syntax),
                    // or the email is not unique.
                    window.alert(formField.error)
                } else if (formField.id === "password") {
                    // Password validation failed.
                    // Maybe it didn't match the password strength
                    window.alert(formField.error)
                }
            })
        } else if (response.status === "SIGN_UP_NOT_ALLOWED") {
            // the reason string is a user friendly message
            // about what went wrong. It can also contain a support code which users
            // can tell you so you know why their sign up was not allowed.
            window.alert(response.reason)
        } else {
            // sign up successful. The session tokens are automatically handled by
            // the frontend SDK.
            window.location.href = "/homepage"
        }
    } catch (err: any) {
        if (err.isSuperTokensGeneralError === true) {
            // this may be a custom error message sent from the API by you.
            window.alert(err.message);
        } else {
            window.alert("Oops! Something went wrong.");
        }
    }
}
```

</TabItem>
<TabItem value="script">

```tsx
import supertokensEmailPassword from "supertokens-web-js-script/recipe/emailpassword";
async function signUpClicked(email: string, password: string) {
    try {
        let response = await supertokensEmailPassword.signUp({
            formFields: [{
                id: "email",
                value: email
            }, {
                id: "password",
                value: password
            }]
        })

        if (response.status === "FIELD_ERROR") {
            // one of the input formFields failed validation
            response.formFields.forEach(formField => {
                if (formField.id === "email") {
                    // Email validation failed (for example incorrect email syntax),
                    // or the email is not unique.
                    window.alert(formField.error)
                } else if (formField.id === "password") {
                    // Password validation failed.
                    // Maybe it didn't match the password strength
                    window.alert(formField.error)
                }
            })
        } else if (response.status === "SIGN_UP_NOT_ALLOWED") { 
            // the reason string is a user friendly message
            // about what went wrong. It can also contain a support code which users
            // can tell you so you know why their sign in was not allowed.
            window.alert(response.reason)
        } else {
            // sign up successful. The session tokens are automatically handled by
            // the frontend SDK.
            window.location.href = "/homepage"
        }
    } catch (err: any) {
        if (err.isSuperTokensGeneralError === true) {
            // this may be a custom error message sent from the API by you.
            window.alert(err.message);
        } else {
            window.alert("Oops! Something went wrong.");
        }
    }
}
```

</TabItem>
</NpmOrScriptTabs>

</TabItem>

<TabItem value="mobile">

<AppInfoForm askForAPIDomain showMultiTenancyTab>

Call the follwing API when the user clicks on the sign up button (the command below can be tried on your terminal).

```bash
curl --location --request POST '^{form_apiDomain}^{form_apiBasePath}/signup' \
--header 'Content-Type: application/json; charset=utf-8' \
--data-raw '{
    "formFields": [{
        "id": "email",
        "value": "john@example.com"
    }, {
        "id": "password",
        "value": "somePassword123"
    }]
}'
```

</AppInfoForm>

The response body from the API call has a `status` property in it:
- `status: "OK"`: User creation was successful. The response also contains more information about the user, for example their user ID.
- `status: "FIELD_ERROR"`: One of the form field inputs failed validation. The response body contains information about which form field input based on the `id`:
    - The email could fail validation if it's syntactically not an email, of it it's not unique.
    - The password could fail validation if it's not string enough (as defined by the backend password validator).

    Either way, you want to show the user an error next to the input form field.
- `status: "GENERAL_ERROR"`: This is only possible if you have overriden the backend API to send back a custom error message which should be displayed on the frontend.
- `status: "SIGN_UP_NOT_ALLOWED"`: This can happen during automatic account linking or during MFA. The `reason` prop that's in the response body contains a support code using which you can see why the sign up was not allowed.

</TabItem>

</FrontendCustomUITabs>

The `formFields` input is a key-value array. You must provide it an `email` and a `password` value at a minimum. If you want to provide additional items, for example the user's name or age, you can append it to the array like so:

```json
{
    "formFields": [{
        "id": "email",
        "value": "john@example.com"
    }, {
        "id": "password",
        "value": "somePassword123"
    }, {
        "id": "name",
        "value": "John Doe"
    }]
}
```

On the backend, the `formFields` array will be available to you for consumption.

:::note
On success, the backend will send back session tokens as part of the response headers which will be automatically handled by our frontend SDK for you.
:::

### How to Check if an Email is Unique

As a part of the sign up form, you may want to explicitly check that the entered email is unique. Whilst this is already done via the sign up API call, it may be a better UX to warn the user about a non unique email right after they finish typing it.

<FrontendCustomUITabs>
<TabItem value="web">

<NpmOrScriptTabs>
<TabItem value="npm">

```tsx
import { doesEmailExist } from "supertokens-web-js/recipe/emailpassword";

async function checkEmail(email: string) {
    try {
        let response = await doesEmailExist({
            email
        });

        if (response.doesExist) {
            window.alert("Email already exists. Please sign in instead")
        }
    } catch (err: any) {
        if (err.isSuperTokensGeneralError === true) {
            // this may be a custom error message sent from the API by you.
            window.alert(err.message);
        } else {
            window.alert("Oops! Something went wrong.");
        }
    }
}
```

</TabItem>
<TabItem value="script">

```tsx
import supertokensEmailPassword from "supertokens-web-js-script/recipe/emailpassword";
async function checkEmail(email: string) {
    try {
        let response = await supertokensEmailPassword.doesEmailExist({
            email
        });

        if (response.doesExist) {
            window.alert("Email already exists. Please sign in instead")
        }
    } catch (err: any) {
        if (err.isSuperTokensGeneralError === true) {
            // this may be a custom error message sent from the API by you.
            window.alert(err.message);
        } else {
            window.alert("Oops! Something went wrong.");
        }
    }
}
```

</TabItem>
</NpmOrScriptTabs>

</TabItem>

<TabItem value="mobile">

<AppInfoForm askForAPIDomain showMultiTenancyTab>

```bash
curl --location --request GET '^{form_apiDomain}^{form_apiBasePath}/emailpassword/email/exists?email=john@example.com'
```

</AppInfoForm>

The response body from the API call has a `status` property in it:
- `status: "OK"`: The response will also contain a `exists` boolean which will be `true` if the input email already belongs to an email password user.
- `status: "GENERAL_ERROR"`: This is only possible if you have overriden the backend API to send back a custom error message which should be displayed on the frontend.

</TabItem>

</FrontendCustomUITabs>

## 4. Add the Sign In Form

<FrontendCustomUITabs>
<TabItem value="web">

Call the follwing function when the user clicks on the sign in button.

<NpmOrScriptTabs>
<TabItem value="npm">

```tsx
import { signIn } from "supertokens-web-js/recipe/emailpassword";

async function signInClicked(email: string, password: string) {
    try {
        let response = await signIn({
            formFields: [{
                id: "email",
                value: email
            }, {
                id: "password",
                value: password
            }]
        })

        if (response.status === "FIELD_ERROR") {
            response.formFields.forEach(formField => {
                if (formField.id === "email") {
                    // Email validation failed (for example incorrect email syntax).
                    window.alert(formField.error)
                }
            })
        } else if (response.status === "WRONG_CREDENTIALS_ERROR") {
            window.alert("Email password combination is incorrect.")
        } else if (response.status === "SIGN_IN_NOT_ALLOWED") {
            // the reason string is a user friendly message
            // about what went wrong. It can also contain a support code which users
            // can tell you so you know why their sign in was not allowed.
            window.alert(response.reason)
        } else {
            // sign in successful. The session tokens are automatically handled by
            // the frontend SDK.
            window.location.href = "/homepage"
        }
    } catch (err: any) {
        if (err.isSuperTokensGeneralError === true) {
            // this may be a custom error message sent from the API by you.
            window.alert(err.message);
        } else {
            window.alert("Oops! Something went wrong.");
        }
    }
}
```

</TabItem>
<TabItem value="script">

```tsx
import supertokensEmailPassword from "supertokens-web-js-script/recipe/emailpassword";
async function signInClicked(email: string, password: string) {
    try {
        let response = await supertokensEmailPassword.signIn({
            formFields: [{
                id: "email",
                value: email
            }, {
                id: "password",
                value: password
            }]
        })

        if (response.status === "FIELD_ERROR") {
            // one of the input formFields failed validation
            response.formFields.forEach(formField => {
                if (formField.id === "email") {
                    // Email validation failed (for example incorrect email syntax).
                    window.alert(formField.error)
                }
            })
        } else if (response.status === "WRONG_CREDENTIALS_ERROR") {
            window.alert("Email password combination is incorrect.")
        } else if (response.status === "SIGN_IN_NOT_ALLOWED") {
            // the reason string is a user friendly message
            // about what went wrong. It can also contain a support code which users
            // can tell you so you know why their sign in was not allowed.
            window.alert(response.reason)
        } else {
            // sign in successful. The session tokens are automatically handled by
            // the frontend SDK.
            window.location.href = "/homepage"
        }
    } catch (err: any) {
        if (err.isSuperTokensGeneralError === true) {
            // this may be a custom error message sent from the API by you.
            window.alert(err.message);
        } else {
            window.alert("Oops! Something went wrong.");
        }
    }
}
```

</TabItem>
</NpmOrScriptTabs>

</TabItem>

<TabItem value="mobile">

<AppInfoForm askForAPIDomain showMultiTenancyTab>

Call the follwing API when the user clicks on the sign in button (the command below can be tried on your terminal).

```bash
curl --location --request POST '^{form_apiDomain}^{form_apiBasePath}/signin' \
--header 'Content-Type: application/json; charset=utf-8' \
--data-raw '{
    "formFields": [{
        "id": "email",
        "value": "john@example.com"
    }, {
        "id": "password",
        "value": "somePassword123"
    }]
}'
```

</AppInfoForm>

The response body from the API call has a `status` property in it:
- `status: "OK"`: User sign in was successful. The response also contains more information about the user, for example their user ID.
- `status: "WRONG_CREDENTIALS_ERROR"`: The input email and password combination is incorrect.
- `status: "FIELD_ERROR"`: This indicates that the input email did not pass the backend validation - probably because it's syntactically not an email. You want to show the user an error next to the email input form field.
- `status: "GENERAL_ERROR"`: This is only possible if you have overriden the backend API to send back a custom error message which should be displayed on the frontend.
- `status: "SIGN_IN_NOT_ALLOWED"`: This can happen during automatic account linking or during MFA. The `reason` prop that's in the response body contains a support code using which you can see why the sign in was not allowed.

</TabItem>

</FrontendCustomUITabs>

:::important
On success, the backend will send back session tokens as part of the response headers which will be automatically handled by our frontend SDK for you.
:::

## 5. Handle Session Tokens

There are two modes ways in which you can use sessions with SuperTokens:
- Using `httpOnly` cookies
- Authorization bearer token.

Our frontend SDK uses `httpOnly` cookie based session for websites by default as it secures against tokens theft via XSS attacks. For other platform like mobile apps, we use a bearer token in the Authorization header by default. This setting can be changed [as described in the token transfer section](../common-customizations/sessions/token-transfer-method)

<OAuthVerifyTokensDisclaimer />

import NetworkInterceptors from "/session/reusableMD/networkInterceptors.mdx"

### With the Frontend SDK

<FrontendCustomUITabs>
<TabItem value="web">

:::success
No action required.
:::

Our frontend SDK handles everything for you. You only need to make sure that you have called `supertokens.init` before making any network requests.

Our SDK adds interceptors to `fetch` and `XHR` (used by `axios`) to save and add session tokens from and to the request.

By default, our web SDKs use cookies to provide credentials.

<OAuthVerifyTokensDisclaimer />

</TabItem>

<TabItem value="mobile">

<FrontendMobileSubTabs>

<TabItem value="reactnative">

Our frontend SDK handles everything for you. You only need to make sure that you have added our network interceptors as shown below

<NetworkInterceptors />

:::note
By default our mobile SDKs use a bearer token in the Authorization header to provide credentials.
:::

</TabItem>

<TabItem value="android">


<Question
    question="Which library are you using for networking?">
<Answer title="HttpURLConnection">

```kotlin
import android.app.Application
import com.supertokens.session.SuperTokens
import com.supertokens.session.SuperTokensHttpURLConnection
import com.supertokens.session.SuperTokensPersistentCookieStore
import java.net.URL
import java.net.HttpURLConnection

class MainApplication: Application() {
    override fun onCreate() {
        super.onCreate()
        // TODO: Make sure to call SuperTokens.init
    }
    
    fun makeRequest() {
        val url = URL("<API_URL>")
        val connection = SuperTokensHttpURLConnection.newRequest(url, object: SuperTokensHttpURLConnection.PreConnectCallback {
            override fun doAction(con: HttpURLConnection?) {
                // TODO: Use `con` to set request method, headers etc
            }
        })
        
        // Handle response using connection object, for example:
        if (connection.responseCode == 200) {
            // TODO: implement 
        }
    }
}
```

:::note
When making network requests you do not need to call `HttpURLConnection.connect` because SuperTokens does this for you.
:::

</Answer>
<Answer title="Okhttp / Retrofit">

```kotlin
import android.content.Context
import com.supertokens.session.SuperTokens
import com.supertokens.session.SuperTokensInterceptor
import okhttp3.OkHttpClient
import retrofit2.Retrofit

class NetworkManager {
    fun getClient(context: Context): OkHttpClient {
        val clientBuilder = OkHttpClient.Builder()
        clientBuilder.addInterceptor(SuperTokensInterceptor())
        // TODO: Make sure to call SuperTokens.init

        val client = clientBuilder.build()

        // REQUIRED FOR RETROFIT ONLY
        val instance = Retrofit.Builder()
            .baseUrl("<YOUR_BASE_URL>")
            .client(client)
            .build()

        return client
    }

    fun makeRequest(context: Context) {
        val client = getClient(context)
        // Use client to make requests normally
    }
}
```

</Answer>
</Question>

:::note
By default our mobile SDKs use a bearer token in the Authorization header to provide credentials.
:::

</TabItem>

<TabItem value="ios">

<Question question="Which library are you using for networking?">

<Answer title="URLSession">

<h4>Using <code>URLSession.shared</code></h4>

```swift
import Foundation
import SuperTokensIOS

fileprivate class NetworkManager {
    func setupSuperTokensInterceptor() {
        URLProtocol.registerClass(SuperTokensURLProtocol.self)
    }
}
```

<h4>Using a custom <code>URLSession</code> instance</h4>

```swift
import Foundation
import SuperTokensIOS

fileprivate class NetworkManager {
    func setupSuperTokensInterceptor() {
        let configuration = URLSessionConfiguration.default
        configuration.protocolClasses = [SuperTokensURLProtocol.self]
        let session = URLSession(configuration: configuration)

        // Use session when making network requests
    }
}
```

</Answer>

<Answer title="Alamofire">

```swift
import Foundation
import SuperTokensIOS
import Alamofire

fileprivate class NetworkManager {
    func setupSuperTokensInterceptor() {
        let configuration = URLSessionConfiguration.af.default
        configuration.protocolClasses = [SuperTokensURLProtocol.self] + (configuration.protocolClasses ?? [])
        let session = Session(configuration: configuration)

        // Use session when making network requests
    }
}
```

</Answer>

</Question>

:::note
By default our mobile SDKs use a bearer token in the Authorization header to provide credentials.
:::

</TabItem>

<TabItem value="flutter">

<Question
    question="Which library are you using for networking?">
<Answer title="http">

You can make requests as you normally would with `http`, the only difference is that you import the client from the supertokens package instead.

```dart
// Import http from the SuperTokens package
import 'package:supertokens_flutter/http.dart' as http;

Future<void> makeRequest() async {
    Uri uri = Uri.parse("http://localhost:3001/api");
    var response = await http.get(uri);
    // handle response
}
```

<h4>Using a custom http client</h4>

If you use a custom http client and want to use SuperTokens, you can simply provide the SDK with your client. All requests will continue to use your client along with the session logic that SuperTokens provides.

```dart
// Import http from the SuperTokens package
import 'package:supertokens_flutter/http.dart' as http;

Future<void> makeRequest() async {
    Uri uri = Uri.parse("http://localhost:3001/api");

    // Initialise your custom client
    var customClient = http.Client();
    // provide your custom client to SuperTokens
    var httpClient = http.Client(client: customClient);

    var response = await httpClient.get(uri);
    // handle response
}
```

</Answer>
<Answer title="Dio">

<h4>Add the SuperTokens interceptor</h4>

Use the extension method provided by the SuperTokens SDK to enable interception on your Dio client. This allows the SuperTokens SDK to handle session tokens for you.

```dart
import 'package:supertokens_flutter/dio.dart';
import 'package:dio/dio.dart';

void setup() {
  Dio dio = Dio();  // Create a Dio instance.
  dio.addSupertokensInterceptor();
}
```

<h4>Making network requests</h4>

You can make requests as you normally would with `dio`.

```dart
import 'package:supertokens_flutter/dio.dart';
import 'package:dio/dio.dart';

void setup() {
    Dio dio = Dio(
        // Provide your config here
    );
    dio.addSupertokensInterceptor();

    var response = dio.get("http://localhost:3001/api");
    // handle response
}
```

</Answer>
</Question>

:::note
By default our mobile SDKs use a bearer token in the Authorization header to provide credentials.
:::

</TabItem>

</FrontendMobileSubTabs>

</TabItem>
</FrontendCustomUITabs>

### Without the Frontend SDK

:::caution
We highly recommend using our frontend SDK to handle session token management. It will save you a lot of time.
:::

In this case, you will need to manually handle the tokens and session refreshing, and decide if you are going to use header or cookie-based sessions.

For browsers, we recommend cookies, while for mobile apps (or if you don't want to use the built-in cookie manager) you should use header-based sessions.

<Question question="Which request authentication mode are you using?" defaultAnswer="Cookie">
    
<Answer title="Cookie">

#### During the Login Action 

You should attach the `st-auth-mode` header to calls to the login API, but this header is safe to attach to all requests. In this case it should be set to "cookie".

The login API will return the following headers:
- `Set-Cookie`: This will contain the `sAccessToken`, `sRefreshToken` cookies which will be `httpOnly` and will be automatically mananaged by the browser. For mobile apps, you will need to setup cookie handling yourself, use our SDK or use a header based authentication mode.
- `front-token` header: This contains information about the access token:
    - The userID
    - The expiry time of the access token
    - The payload added by you in the access token.
    
    Here is the structure of the token:
    ```tsx
    let frontTokenFromRequestHeader = "...";
    let frontTokenDecoded = JSON.parse(decodeURIComponent(escape(atob(frontTokenFromRequestHeader))));
    console.log(frontTokenDecoded);
    /*
    {
        ate: 1665226412455, // time in milliseconds for when the access token will expire, and then a refresh is required
        uid: "....", // user ID
        up: {
            sub: "..",
            iat: ..,
            ... // other access token payload
        }
    }
    
    */
    ```

    This token is mainly used for cookie based auth because you don't have access to the actual access token on the frontend (for security reasons), but may want to read its payload (for example to know the user's role). This token itself is not signed and hence can't be used in place of the access token itself. You may want to save this token in localstorage or in frontend cookies (using `document.cookies`).

- `anti-csrf` header (optional): By default it's not required, so it's not sent. But if this is sent, you should save this token as well for use when making requests.

#### When You Make Network Requests to Protected APIs

The `sAccessToken` will get attached to the request automatically by the browser. Other than that, you need to add the following headers to the request:
- `rid: "anti-csrf"` - this prevents against anti-CSRF requests. If your `apiDomain` and `websiteDomain` values are exactly the same, then this is not necessary.
- `anti-csrf` header (optional): If this was provided to you during login, then you need to add that token as the value of this header.
- You need to set the `credentials` header to `true` or `include`. This is achieved different based on the library you are using to make requests.

An API call can potentially update the `sAccessToken` and `front-token` tokens, for example if you call the `mergeIntoAccessTokenPayload` function on the `session` object on the backend. This kind of update is reflected in the response headers for your API calls. The headers will contain new values for:
- `sAccessToken`: This will be as a new `Set-Cookie` header and will be managed by the browser automatically.
- `front-token`: This should be read and saved by you in the same way as it's being done during login.

#### Handling session refreshing

If any of your API calls return with a status code of `401`, it means that the access token has expired. This will require you to refresh the session before retrying the same API call.

You can call the refresh API as follows:

<AppInfoForm askForAPIDomain>

```bash
curl --location --request POST '^{form_apiDomain}^{form_apiBasePath}/session/refresh' \
--header 'Cookie: sRefreshToken=...'
```

:::note
- You may also need to add the `anti-csrf` header to the request if that was provided to you during sign in.
- The cURL command above shows the `sRefreshToken` cookie as well, but this is added by the web browser automatically, so you don't need to add it explicitly.
:::

</AppInfoForm>

The result of a session refresh will be either:
- Status code `200`: This implies a succesful refresh. The set of tokens returned here will be the same as when the user logs in, so you can handle them in the same way.
- Status code `401`: This means that the refresh token is invalid, or has been revoked. You must ask the user to relogin. Remember to clear the `front-token` that you saved on the frontend earlier.

</Answer>

<Answer title="Header (Authorization Bearer)">

##### During the Login Action

You should attach the `st-auth-mode` header to calls to the login API, but this header is safe to attach to all requests. In this case it should be set to "header".

The login API will return the following headers:
- `st-access-token`: This contains the current access token associated with the session. You should save this in your application (e.g., in frontend localstorage).
- `st-refresh-token`: This contains the current refresh token associated with the session. You should save this in your application (e.g., in frontend localstorage).

#### When You Make Network Requests to Protected APIs

You need to add the following headers to request:
- `authorization: Bearer {access-token}`
- You need to set the `credentials` to `true` or `include`. This is achieved different based on the library you are using to make requests.

An API call can potentially update the `access-token`, for example if you call the `mergeIntoAccessTokenPayload` function on the `session` object on the backend. This kind of update is reflected in the response headers for your API calls. The headers will contain new values for `st-access-token`

These should be read and saved by you in the same way as it's being done during login.

#### Handling session refreshing

If any of your API calls return with a status code of `401`, it means that the access token has expired. This will require you to refresh the session before retrying the same API call.

You can call the refresh API as follows:

<AppInfoForm askForAPIDomain>

```bash
curl --location --request POST '^{form_apiDomain}^{form_apiBasePath}/session/refresh' \
--header 'authorization: Bearer {refresh-token}'
```

</AppInfoForm>

The result of a session refresh will be either:
- Status code `200`: This implies a succesful refresh. The set of tokens returned here will be the same as when the user logs in, so you can handle them in the same way.
- Status code `401`: This means that the refresh token is invalid, or has been revoked. You must ask the user to relogin. Remember to clear the `st-refresh-token` and `st-access-token` that you saved on the frontend earlier.

</Answer>

</Question>


## 6. Protect Frontend Routes

<FrontendCustomUITabs>
<TabItem value="web">

<NpmOrScriptTabs>
<TabItem value="npm">

You can use the `doesSessionExist` function to check if a session exists.

```tsx
import Session from 'supertokens-web-js/recipe/session';

async function doesSessionExist() {
    if (await Session.doesSessionExist()) {
        // user is logged in
    } else {
        // user has not logged in yet
    }
}
```

</TabItem>
<TabItem value="script">

You can use the `doesSessionExist` function to check if a session exists.

```tsx
import Session from 'supertokens-web-js-script/recipe/session';
async function doesSessionExist() {
    if (await Session.doesSessionExist()) {
        // user is logged in
    } else {
        // user has not logged in yet
    }
}
```

</TabItem>
</NpmOrScriptTabs>

</TabItem>

<TabItem value="mobile">

<FrontendMobileSubTabs>

<TabItem value="reactnative">

You can use the `doesSessionExist` function to check if a session exists.

```tsx
import SuperTokens from 'supertokens-react-native';

async function doesSessionExist() {
    if (await SuperTokens.doesSessionExist()) {
        // user is logged in
    } else {
        // user has not logged in yet
    }
}
```

</TabItem>

<TabItem value="android">

You can use the `doesSessionExist` function to check if a session exists.

```kotlin
import android.app.Application
import com.supertokens.session.SuperTokens

class MainApplication: Application() {
    fun doesSessionExist() {
        if (SuperTokens.doesSessionExist(this.applicationContext)) {
            // user is logged in
        } else {
            // user has not logged in yet
        }
    }
}
```

</TabItem>

<TabItem value="ios">

You can use the `doesSessionExist` function to check if a session exists.

```swift
import UIKit
import SuperTokensIOS

fileprivate class ViewController: UIViewController {
    func doesSessionExist() {
        if SuperTokens.doesSessionExist() {
            // User is logged in
        } else {
            // User is not logged in
        }
    }
}
```

</TabItem>

<TabItem value="flutter">

You can use the `doesSessionExist` function to check if a session exists.

```dart
import 'package:supertokens_flutter/supertokens.dart';

Future<bool> doesSessionExist() async {
    return await SuperTokens.doesSessionExist();
}
```

</TabItem>

</FrontendMobileSubTabs>

</TabItem>

</FrontendCustomUITabs>

## 7. Add a Sign Out Action

The `signOut` method revokes the session on the frontend and on the backend. Calling this function without a valid session also yields a successful response.

<FrontendCustomUITabs>
<TabItem value="web">

<NpmOrScriptTabs>
<TabItem value="npm">

```tsx
import Session from "supertokens-web-js/recipe/session";

async function logout () {
  // highlight-next-line
  await Session.signOut(); 
  window.location.href = "/auth"; // or to wherever your logic page is
}
```

</TabItem>
<TabItem value="script">

```tsx
import supertokensSession from "supertokens-web-js-script/recipe/session";
async function logout () {
  // highlight-next-line
  await supertokensSession.signOut(); 
  window.location.href = "/auth"; // or to wherever your logic page is
}
```

</TabItem>
</NpmOrScriptTabs>

</TabItem>

<TabItem value="mobile">

<FrontendMobileSubTabs>

<TabItem value="reactnative">

```tsx
import SuperTokens from "supertokens-react-native";

async function logout () {
  // highlight-next-line
  await SuperTokens.signOut(); 
  // navigate to the login screen..
}
```

</TabItem>

<TabItem value="android">

```kotlin
import android.app.Application
import com.supertokens.session.SuperTokens

class MainApplication: Application() {
    fun logout() {
        // highlight-next-line
        SuperTokens.signOut(this);
        // navigate to the login screen..
    }
}
```

</TabItem>

<TabItem value="ios">

```swift
import UIKit
import SuperTokensIOS

fileprivate class ViewController: UIViewController {
  func signOut() {
    SuperTokens.signOut(completionHandler: {
        error in
        
        if error != nil {
            // handle error
        } else {
            // Signed out successfully
        }
    })
  }
}
```

</TabItem>

<TabItem value="flutter">

```dart
import 'package:supertokens_flutter/supertokens.dart';

Future<void> signOut() async {
  await SuperTokens.signOut(
    completionHandler: (error) {
      // handle error if any
    }
  );
}
```

</TabItem>

</FrontendMobileSubTabs>

</TabItem>

</FrontendCustomUITabs>

- On success, the `signOut` function does not redirect the user to another page, so you must redirect the user yourself.
- The `signOut` function calls the signout API exposed by the session recipe on the backend.
- If you call the `signOut` function whilst the access token has expired, but the refresh token still exists, our SDKs will do an automatic session refresh before revoking the session.

## See also

- [Post sign in action](../common-customizations/handling-signin-success)
- [Post sign up action](../common-customizations/handling-signup-success)
- [Adding extra form fields in sign up](../common-customizations/signup-form/adding-fields)
- [Changing fields validation logic on the backend](../common-customizations/signup-form/field-validators)
- [Password hashing algorithms](../common-customizations/password-hashing/about)
- [Disabling sign up on the backend](../advanced-customizations/apis-override/disabling)
- [Customising user ID format](../common-customizations/userid-format)
- Optional sessions [for APIs](../common-customizations/sessions/session-verification-in-api/verify-session#optional-session-verification) and [the frontend](../common-customizations/sessions/checking-session-front-end)
- [Verifying session without using a middleware](../common-customizations/sessions/session-verification-in-api/get-session) 
- Session claim validation [for APIs](../common-customizations/sessions/claims/claim-validators) and [the frontend](../common-customizations/sessions/claims/claim-validators)
- [Changing session lifetime](../common-customizations/sessions/change-session-timeout)
- [Sharing session across sub domains](../common-customizations/sessions/share-sessions-across-sub-domains)
