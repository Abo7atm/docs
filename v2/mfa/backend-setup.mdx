---
id: backend-setup
title: Backend setup
hide_title: true
---

import MFAPaidBanner from '../community/reusableMD/mfa/MFAPaidBanner.mdx'
import BackendSDKTabs from "/src/components/tabs/BackendSDKTabs";
import TabItem from '@theme/TabItem';
import PythonSyncAsyncSubTabs from "/src/components/tabs/PythonSyncAsyncSubTabs";
import CoreInjector from "/src/components/coreInjector"

<MFAPaidBanner />

# Backend setup

## Configuring the first factors

### Single tenant setup

We start by intialising the MFA recipe on the backend and specifying the list of first factors using their [factor IDs](./important-concepts#auth-factor-ids). You still have to initialise all the auth recipes in the `recipeList`, and configure them based on your needs. 

For example, the code below inits `thirdpartyemailpassword` and `passwordless` recipes and sets the `firstFactor` array to be `["emailpassword", "thirdparty"]`. This means that we will show email password and social login to the user as the first factor (using the `thirdpartyemailpassword` recipe), and use `passwordless` for the second factor.

<BackendSDKTabs>
<TabItem value="nodejs">

```ts
import supertokens from "supertokens-node";
import ThirdPartyEmailPassword from "supertokens-node/recipe/thirdpartyemailpassword"
import Passwordless from "supertokens-node/recipe/passwordless"
import MultiFactorAuth from "superTokens-node/recipe/multifactorauth"

supertokens.init({
    supertokens: {
        connectionURI: "..."
    },
    appInfo: {
        appName: "...",
        apiDomain: "...",
        websiteDomain: "..."
    },
    recipeList: [
        // highlight-start
        ThirdPartyEmailPassword.init({
            //...
        }),
        Passwordless.init({
            contactMethod: "EMAIL",
            flowType: "USER_INPUT_CODE"
        }),
        MultiFactorAuth.init({
            firstFactors: ["emailpassword", "thirdparty"]
        })
        // highlight-end
    ]
})
```

</TabItem>
<TabItem value="go">

:::note
Coming soon. In the meantime, checkout the [legacy method](./legacy-method/how-it-works) for adding MFA to your app.
:::

</TabItem>
<TabItem value="python">

:::note
Coming soon. In the meantime, checkout the [legacy method](./legacy-method/how-it-works) for adding MFA to your app.
:::

</TabItem>
</BackendSDKTabs>

There are of course other combinations of first factors that you may want to add. For example, if you want passwordless as the first factor, then you would init the passwordless recipe and add `"passwordless"` in the `firstFactors` array.

### Multi tenant setup

For a multi tenancy setup, where each tenant can have a different set of first factors, you can leave the `firstFactors` array as `undefined` in the `MultiFactorAuth.init` and configure the firstFactors on a per tenant basis when you are creating / updating a tenant as shown below:

<BackendSDKTabs enableCurl>

<TabItem value="nodejs">

```tsx
import Multitenancy from "supertokens-node/recipe/multitenancy";

async function createNewTenant() {
    let resp = await Multitenancy.createOrUpdateTenant("customer1", {
        emailPasswordEnabled: true,
        passwordlessEnabled: true,
        firstFactors: ["emailpassword"]
    });

    if (resp.createdNew) {
        // Tenant created successfully
    } else {
        // Existing tenant's config was modified.
    }
}
```

</TabItem>
<TabItem value="go">

:::note
Coming soon. In the meantime, checkout the [legacy method](./legacy-method/how-it-works) for adding MFA to your app.
:::

</TabItem>
<TabItem value="python">

:::note
Coming soon. In the meantime, checkout the [legacy method](./legacy-method/how-it-works) for adding MFA to your app.
:::

</TabItem>

<TabItem value="curl">

<CoreInjector defaultValue="http://localhost:3567" showAppId={false}>

```bash
curl --location --request PUT '^{coreInjector_uri_without_quotes}/appid-<APP_ID>/recipe/multitenancy/tenant' \
--header 'api-key: ^{coreInjector_api_key_without_quotes}' \
--header 'Content-Type: application/json' \
--data-raw '{
    "tenantId": "customer1",
    "emailPasswordEnabled": true,
    "passwordlessEnabled": true,
    "firstFactors": ["emailpassword"]
}'
```

</CoreInjector>

</TabItem>

</BackendSDKTabs>

In the above, we are enabling email password and passwordless for the tenant, however, we have set `firstFactors` only to include `"emailpassword"`. This means that users who login to this tenant will only be able to use email password as the first factor, even though passwordless is enabled. Later on, we will see how we can configure passwordless as a second factor for this tenant.

:::important
If you do not configure a `firstFactors` array on a tenant config, then it will pick up the values from the `firstFactors` array in the `MultiFactorAuth.init` from the backend's `init` config.
:::

## Configuring a second factor

In this section, we will see how to configure SuperTokens so that a second factor is required for all users during sign up and during sign in. We will use TOTP as an example for the second factor.

### Single tenant setup
This can be achieved easily by the following code snippet:

<BackendSDKTabs>
<TabItem value="nodejs">

```ts
import supertokens from "supertokens-node";
import ThirdPartyEmailPassword from "supertokens-node/recipe/thirdpartyemailpassword"
import Passwordless from "supertokens-node/recipe/passwordless"
import MultiFactorAuth from "superTokens-node/recipe/multifactorauth"
import totp from "supertokens-node/recipe/totp"

supertokens.init({
    supertokens: {
        connectionURI: "..."
    },
    appInfo: {
        appName: "...",
        apiDomain: "...",
        websiteDomain: "..."
    },
    recipeList: [
        ThirdPartyEmailPassword.init({
            //...
        }),
        Passwordless.init({
            contactMethod: "EMAIL",
            flowType: "USER_INPUT_CODE"
        }),
        totp.init(),
        MultiFactorAuth.init({
            firstFactors: ["emailpassword", "thirdparty"],
            // highlight-start
            override: {
                functions: (originalImplementation) => {
                    return {
                        ...originalImplementation,
                        getMFARequirementsForAuth: async function (input) {
                            return ["totp"]
                        }
                    }
                }
            }
            // highlight-end
        })
    ]
})
```

</TabItem>
<TabItem value="go">

:::note
Coming soon. In the meantime, checkout the [legacy method](./legacy-method/how-it-works) for adding MFA to your app.
:::

</TabItem>
<TabItem value="python">

:::note
Coming soon. In the meantime, checkout the [legacy method](./legacy-method/how-it-works) for adding MFA to your app.
:::

</TabItem>
</BackendSDKTabs>

In the above snippet, we have confgured email password and social login as the first factor, followed by totp as the second factor.

After sign in or sign up, SuperTokens calls the `getMFARequirementsForAuth` function to get a list of secondary factors for the user. The returned value is stored in the session's access token payload's `n` array which indicates that this factor needs to be completed next, before the user has access to the full application. If the returned factor is already completed, then it's not readded into the `n` array.

In the above example, we are simply returning `"totp"` as a required factor for all users, but you can also dynamically decide which factor to return based on the `input` arguments, which contains the `User` object, the `tenantId` and the current session's access token payload. In fact, the default implementation of `getMFARequirementsForAuth` returns the set of factors that are specifically enabled for this user (see next section).

The output of this function can be more complex than just a `string`. You can also return an object which tells SuperTokens that any one of the factors need to be completed: 

<BackendSDKTabs>
<TabItem value="nodejs">

```ts
import supertokens from "supertokens-node";
import MultiFactorAuth from "superTokens-node/recipe/multifactorauth"

supertokens.init({
    supertokens: {
        connectionURI: "..."
    },
    appInfo: {
        appName: "...",
        apiDomain: "...",
        websiteDomain: "..."
    },
    recipeList: [
        // ...
        MultiFactorAuth.init({
            firstFactors: ["emailpassword", "thirdparty"],
            override: {
                functions: (originalImplementation) => {
                    return {
                        ...originalImplementation,
                        getMFARequirementsForAuth: async function (input) {
                            // highlight-start
                            return [{
                                oneOf: ["totp", "email-otp"]
                            }]
                            // highlight-end
                        }
                    }
                }
            }
        })
    ]
})
```

</TabItem>
<TabItem value="go">

:::note
Coming soon. In the meantime, checkout the [legacy method](./legacy-method/how-it-works) for adding MFA to your app.
:::

</TabItem>
<TabItem value="python">

:::note
Coming soon. In the meantime, checkout the [legacy method](./legacy-method/how-it-works) for adding MFA to your app.
:::

</TabItem>
</BackendSDKTabs>

Or that all of the factors in the returned array need to be completed:

<BackendSDKTabs>
<TabItem value="nodejs">

```ts
import supertokens from "supertokens-node";
import MultiFactorAuth from "superTokens-node/recipe/multifactorauth"

supertokens.init({
    supertokens: {
        connectionURI: "..."
    },
    appInfo: {
        appName: "...",
        apiDomain: "...",
        websiteDomain: "..."
    },
    recipeList: [
        // ...
        MultiFactorAuth.init({
            firstFactors: ["emailpassword", "thirdparty"],
            override: {
                functions: (originalImplementation) => {
                    return {
                        ...originalImplementation,
                        getMFARequirementsForAuth: async function (input) {
                            // highlight-start
                            return [{
                                allOf: ["totp", "email-otp"]
                            }]
                            // highlight-end
                        }
                    }
                }
            }
        })
    ]
})
```

</TabItem>
<TabItem value="go">

:::note
Coming soon. In the meantime, checkout the [legacy method](./legacy-method/how-it-works) for adding MFA to your app.
:::

</TabItem>
<TabItem value="python">

:::note
Coming soon. In the meantime, checkout the [legacy method](./legacy-method/how-it-works) for adding MFA to your app.
:::

</TabItem>
</BackendSDKTabs>

You can even add a third factor to the auth flow based on the set of factors that are completed as shown below. For example, if you want to have email password / social login as the first factor followed by TOTP and then email OTP, you could do the following:

<BackendSDKTabs>
<TabItem value="nodejs">

```ts
import supertokens from "supertokens-node";
import MultiFactorAuth from "superTokens-node/recipe/multifactorauth"

supertokens.init({
    supertokens: {
        connectionURI: "..."
    },
    appInfo: {
        appName: "...",
        apiDomain: "...",
        websiteDomain: "..."
    },
    recipeList: [
        // ...
        MultiFactorAuth.init({
            firstFactors: ["emailpassword", "thirdparty"],
            override: {
                functions: (originalImplementation) => {
                    return {
                        ...originalImplementation,
                        getMFARequirementsForAuth: async function (input) {
                            // highlight-start
                            let currentCompletedFactors = MultiFactorAuth.MultiFactorAuthClaim.getValueFromPayload(input.accessTokenPayload)
                            if ("totp" in currentCompletedFactors) {
                                // this means the totp factor is completed
                                return ["email-otp"]
                            } else {
                                // this means we have not finished totp yet, and we want 
                                // to do that right after first factor login
                                return ["totp"]
                            }
                            // highlight-end
                        }
                    }
                }
            }
        })
    ]
})
```

</TabItem>
<TabItem value="go">

:::note
Coming soon. In the meantime, checkout the [legacy method](./legacy-method/how-it-works) for adding MFA to your app.
:::

</TabItem>
<TabItem value="python">

:::note
Coming soon. In the meantime, checkout the [legacy method](./legacy-method/how-it-works) for adding MFA to your app.
:::

</TabItem>
</BackendSDKTabs>

You can return an empty array from `getMFARequirementsForAuth` if you don't want any further MFA done for the current user.

If you return more than one item from the array, it would mean that the user has to satisfy the criteria for each of the items. For example, if we returnt the following from `getMFARequirementsForAuth`:

```ts
let requirements = [{
    oneOf: ["f1", "f2"]
}, {
    allOf: ["f3", "f4"]
}, "f5"]
```

Then the user will have to complete (`f1` or `f2`) and `f3`, `f4`, `f5` to complete login.

All of the above is only useful to populate the values of the [`n` and `c` values](./important-concepts#how-are-auth-factors-marked-as-completed) in the session's access token payload. However, you still need to [protect the frontend and API routes](./protect-routes) to ensure that those resources are given access to only if the user has an empty `n` array (indicating that all factors have been completed).


### Multi tenant setup
For a multi tenant setup, you can configure a list of secondary factors when creating / modifying a tenant as shown below:

<BackendSDKTabs enableCurl>

<TabItem value="nodejs">

```tsx
import Multitenancy from "supertokens-node/recipe/multitenancy";

async function createNewTenant() {
    let resp = await Multitenancy.createOrUpdateTenant("customer1", {
        emailPasswordEnabled: true,
        passwordlessEnabled: true,
        firstFactors: ["emailpassword"],
        requiredSecondaryFactors: ["email-otp"]
    });

    if (resp.createdNew) {
        // Tenant created successfully
    } else {
        // Existing tenant's config was modified.
    }
}
```

</TabItem>
<TabItem value="go">

:::note
Coming soon. In the meantime, checkout the [legacy method](./legacy-method/how-it-works) for adding MFA to your app.
:::

</TabItem>
<TabItem value="python">

:::note
Coming soon. In the meantime, checkout the [legacy method](./legacy-method/how-it-works) for adding MFA to your app.
:::

</TabItem>

<TabItem value="curl">

<CoreInjector defaultValue="http://localhost:3567" showAppId={false}>

```bash
curl --location --request PUT '^{coreInjector_uri_without_quotes}/appid-<APP_ID>/recipe/multitenancy/tenant' \
--header 'api-key: ^{coreInjector_api_key_without_quotes}' \
--header 'Content-Type: application/json' \
--data-raw '{
    "tenantId": "customer1",
    "emailPasswordEnabled": true,
    "passwordlessEnabled": true,
    "firstFactors": ["emailpassword"],
    "requiredSecondaryFactors": ["email-otp"]
}'
```

</CoreInjector>

</TabItem>

</BackendSDKTabs>

In the above code, we add a propery called `requiredSecondaryFactors` for a tenant whose value is a `string[]`. We add `email-otp` as a factor ID above which means that all users who log into that tenant must complete `email-otp` as a second factor. This factor comes from the passwordless recipe, and so we have also set `passwordlessEnabled: true`.

If you add more than one item in this array, it means that the user must complete any one of factors mentioned in the array. If you want to have a different behaviour for the tenant, you can achieve that by overriding the `getMFARequirementsForAuth` function as shown below:

<BackendSDKTabs>
<TabItem value="nodejs">

```ts
import supertokens from "supertokens-node";
import MultiFactorAuth from "superTokens-node/recipe/multifactorauth"

supertokens.init({
    supertokens: {
        connectionURI: "..."
    },
    appInfo: {
        appName: "...",
        apiDomain: "...",
        websiteDomain: "..."
    },
    recipeList: [
        // ...
        MultiFactorAuth.init({
            firstFactors: ["emailpassword", "thirdparty"],
            override: {
                functions: (originalImplementation) => {
                    return {
                        ...originalImplementation,
                        getMFARequirementsForAuth: async function (input) {
                            // highlight-start
                            return [{
                                allOf: input.requiredSecondaryFactorsForTenant
                            }]
                            // highlight-end
                        }
                    }
                }
            }
        })
    ]
})
```

</TabItem>
<TabItem value="go">

:::note
Coming soon. In the meantime, checkout the [legacy method](./legacy-method/how-it-works) for adding MFA to your app.
:::

</TabItem>
<TabItem value="python">

:::note
Coming soon. In the meantime, checkout the [legacy method](./legacy-method/how-it-works) for adding MFA to your app.
:::

</TabItem>
</BackendSDKTabs>

Notice that the input to the function contains the `requiredSecondaryFactorsForTenant` array. This would be the same list that you passed to the tenant config when creating / modifying the tenant as shown in the previous steps.

### Functions to help with configuring a second factor for each user optionally
TODO