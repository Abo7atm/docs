---
id: totp-for-all-users
title: TOTP required for all users
hide_title: true
show_ui_switcher: true
---

import MFAPaidBanner from '../../community/reusableMD/mfa/MFAPaidBanner.mdx'
import BackendSDKTabs from "/src/components/tabs/BackendSDKTabs";
import TabItem from '@theme/TabItem';
import PythonSyncAsyncSubTabs from "/src/components/tabs/PythonSyncAsyncSubTabs";
import CoreInjector from "/src/components/coreInjector"
import CustomAdmonition from "/src/components/customAdmonition"
import {Question, Answer}from "/src/components/question"
import FrontendPreBuiltUITabs from "/src/components/tabs/FrontendPreBuiltUITabs"
import {PreBuiltOrCustomUISwitcher, PreBuiltUIContent, CustomUIContent} from "/src/components/preBuiltOrCustomUISwitcher"
import FrontendCustomUITabs from "/src/components/tabs/FrontendCustomUITabs"
import NpmOrScriptTabs from "/src/components/tabs/NpmOrScriptTabs"
import AppInfoForm from "/src/components/appInfoForm"
import FrontendMobileSubTabs from "/src/components/tabs/FrontendMobileSubTabs"

<MFAPaidBanner />

# TOTP required for all users

In this page, we will show you how to implement an MFA policy that requires all users to use TOTP before they get access to your application.

:::note
We assume that the first factor is [email password or social login](/docs/thirdpartyemailpassword/introduction), but the same set of steps will be applicable for other first factor types as well.
:::

## Single tenant setup

### Backend setup
To start with, we cofigure the backend in the following way:

<BackendSDKTabs>
<TabItem value="nodejs">

```ts
import supertokens from "supertokens-node";
import ThirdPartyEmailPassword from "supertokens-node/recipe/thirdpartyemailpassword"
import MultiFactorAuth from "supertokens-node/recipe/multifactorauth"
import totp from "supertokens-node/recipe/totp"
import Session from "supertokens-node/recipe/session"

supertokens.init({
    supertokens: {
        connectionURI: "..."
    },
    appInfo: {
        appName: "...",
        apiDomain: "...",
        websiteDomain: "..."
    },
    recipeList: [
        Session.init(),
        ThirdPartyEmailPassword.init({
            //...
        }),
        // highlight-next-line
        totp.init(),
        MultiFactorAuth.init({
            firstFactors: ["emailpassword", "thirdparty"],
            // highlight-start
            override: {
                functions: (originalImplementation) => {
                    return {
                        ...originalImplementation,
                        getMFARequirementsForAuth: async function (input) {
                            return ["totp"]
                        }
                    }
                }
            }
            // highlight-end
        })
    ]
})
```

</TabItem>
<TabItem value="go">

:::note
Coming soon. In the meantime, checkout the [legacy method](./legacy-method/how-it-works) for adding MFA to your app.
:::

</TabItem>
<TabItem value="python">

:::note
Coming soon. In the meantime, checkout the [legacy method](./legacy-method/how-it-works) for adding MFA to your app.
:::

</TabItem>
</BackendSDKTabs>

- Notice that we have initialised the TOTP recipe in the `recipeList`.
- We also override the `getMFARequirementsForAuth` function to indicate that `totp` must be completed before the user can access the app. Notice that we do not check for the userId there, and return `totp` for all users.

Once the user finishes the first factor (for example, with emailpassword), their session access token payload will look like this:
```json
{
    "st-mfa": {
        "c": {
            "emailpassword": 1702877939,
        },
        "v": false
    }
}
```

The `v` being `false` indicates that there are still factors that are pending. After the user has finished totp, the payload will look like:

```json
{
    "st-mfa": {
        "c": {
            "emailpassword": 1702877939,
            "totp": 1702877999
        },
        "v": true
    }
}
```

Indicating that the user has finished all required factors, and should be allowed to access the app.

### Frontend setup

<PreBuiltOrCustomUISwitcher>

<PreBuiltUIContent>

We start by modifying the `init` function call on the frontend like so:

<FrontendPreBuiltUITabs>

<TabItem value="reactjs">

```tsx
import supertokens from "supertokens-auth-react"
import ThirdPartyEmailPassword from "supertokens-auth-react/recipe/thirdpartyemailpassword"
import Passwordless from "supertokens-auth-react/recipe/passwordless"
import MultiFactorAuth from "supertokens-auth-react/recipe/multifactorauth"
import totp from "supertokens-auth-react/recipe/totp"

supertokens.init({
    appInfo: {
        appName: "...",
        apiDomain: "...",
        websiteDomain: "...",
    },
    recipeList: [
        ThirdPartyEmailPassword.init( /* ... */),
        // highlight-start
        totp.init(),
        MultiFactorAuth.init({
            firstFactors: ["emailpassword", "thirdparty"]
        })
        // highlight-end
    ]
})
```

</TabItem>

</FrontendPreBuiltUITabs>

- Just like on the backend, we init the `totp` recipe in the `recipeList`.
- We also init the `MultiFactorAuth` recipe, and pass in the first factors that we want to use. In this case, that would be `emailpassword` and `thirdparty` - same as the backend.

Next, we need to add the TOTP pre built UI when rendering the SuperTokens component:

<FrontendPreBuiltUITabs>

<TabItem value="reactjs">

<Question
    question="Do you use react-router-dom?">
<Answer title="Yes">

```tsx
import { SuperTokensWrapper } from "supertokens-auth-react";
import { getSuperTokensRoutesForReactRouterDom } from "supertokens-auth-react/ui";
import { ThirdPartyEmailPasswordPreBuiltUI } from "supertokens-auth-react/recipe/thirdpartyemailpassword/prebuiltui"; 
import { TOTPPreBuiltUI } from "supertokens-auth-react/recipe/totp/prebuiltui";
import reactRouterDOM, { Routes, BrowserRouter as Router, Route } from "react-router-dom";

function App() {
  return (
    <SuperTokensWrapper>
      <div className="App">
        <Router>
          <div className="fill">
            <Routes>
              // highlight-start 
              {getSuperTokensRoutesForReactRouterDom(reactRouterDOM, [ThirdPartyEmailPasswordPreBuiltUI, TOTPPreBuiltUI])}
              // highlight-end 
              // ... other routes
            </Routes>
          </div>
        </Router>
      </div>
    </SuperTokensWrapper>
  );
}
```

</Answer>

<Answer title="No">

```tsx
import { SuperTokensWrapper } from "supertokens-auth-react";
import { canHandleRoute, getRoutingComponent } from "supertokens-auth-react/ui";
import { ThirdPartyEmailPasswordPreBuiltUI } from "supertokens-auth-react/recipe/thirdpartyemailpassword/prebuiltui"; 
import { TOTPPreBuiltUI } from "supertokens-auth-react/recipe/totp/prebuiltui";

function App() {
  // highlight-start
  if (canHandleRoute([ThirdPartyEmailPasswordPreBuiltUI, TOTPPreBuiltUI])) {
      return getRoutingComponent([ThirdPartyEmailPasswordPreBuiltUI, TOTPPreBuiltUI])
  }
  // highlight-end
  return (
    <SuperTokensWrapper>{/*Your app*/}</SuperTokensWrapper>
  );
}
```

</Answer>

</Question>

</TabItem>

</FrontendPreBuiltUITabs>

With the above configuration, users will see emailpassword or social login UI when they visit the auth page. After completing that, users will be redirected to `/auth/mfa/totp` (assuming that the `websiteBasePath` is `/auth`) where they will be asked to setup the factor, or complete the TOTP challenge if they have already setup the factor before. The UI for this screen looks like:
- [Factor Setup UI](https://6571be2867f75556541fde98-xieqfaxuuo.chromatic.com/?path=/story/totp-mfa--device-setup-with-single-next-option)
- [Verification UI](https://6571be2867f75556541fde98-xieqfaxuuo.chromatic.com/?path=/story/totp-mfa--verification-with-single-next-option) (In case the factor is already setup before).

</PreBuiltUIContent>

<CustomUIContent>

We start by initialising the MFA and TOTP recipe on the frontend like so:

<FrontendCustomUITabs>

<TabItem value="web">

<NpmOrScriptTabs>

<TabItem value="npm">

```tsx
import SuperTokens from 'supertokens-web-js';
import MultiFactorAuth from 'supertokens-web-js/recipe/multifactorauth';
import Totp from "supertokens-web-js/recipe/totp";

SuperTokens.init({
    appInfo: {
        apiDomain: "...",
        apiBasePath: "...",
        appName: "...",
    },
    recipeList: [
        // other recipes...
        // highlight-start
        MultiFactorAuth.init(),
        Totp.init()
        // highlight-end
    ],
});
```

</TabItem>

<TabItem value="script">

```tsx
import supertokens from "supertokens-web-js-script";
import supertokensMultiFactorAuth from 'supertokens-web-js-script/recipe/multifactorauth';
import supertokensTotp from "supertokens-web-js-script/recipe/totp";
supertokens.init({
    appInfo: {
        apiDomain: "...",
        apiBasePath: "...",
        appName: "...",
    },
    recipeList: [
        // other recipes...
        // highlight-start
        supertokensMultiFactorAuth.init(),
        supertokensTotp.init()
        // highlight-end
    ],
});
```

</TabItem>


</NpmOrScriptTabs>

</TabItem>

<TabItem value="mobile">

:::success
This step is not applicable for mobile apps. Please continue reading.
:::

</TabItem>

</FrontendCustomUITabs>

After the first factor login, you should start by [checking the access token payload and see if the MFA claim's `v` boolean is `false`](../frontend-setup#step-2-checking-the---custv-boolean-value-in-the-mfa-claim--cust). If it's not, then we can redeirect the user to the application page.

If it's `false`, the frontend then needs to [call the MFA endpoint](../frontend-setup#mfa-info-endpoint) to get information about which factor the user should be asked to complete next. Based on the backend config in this page, the `next` array will contain `["totp"]`.

There are two possibilities here:
- Case 1: The user needs to setup a TOTP device cause they don't have any.
- Case 2: The user already has a verified device setup and needs to complete the TOTP challenge.

We can know which case it is by checking if `"totp"` is one of the items in the `factorsThatAreAlreadySetup` array that is returned from the API call above. If it is in the array, then it's case 2, otherwise it's case 1.

#### Case 1 implementation: User needs to setup a new TOTP device
In this case, we do two things:
- Call an API on the backend to create a device. This returns the device secret that can be displayed to the user. The user is supposed to scan this using their authenticator app, to add a new entry for your app in their authenticator app.
- Then the user needs to enter the TOTP code that's displayed to them in the app, and this needs to be sent to the backend to mark the device as verified. Once a device is marked as verified, only then will the `factorsThatAreAlreadySetup` array contain `"totp"` the next time they login.

To create a new device, call the following API:

<FrontendCustomUITabs>

<TabItem value="web">

<NpmOrScriptTabs>

<TabItem value="npm">

```tsx
import Totp from "supertokens-web-js/recipe/totp"
import Session from "supertokens-web-js/recipe/session"

async function createNewTotpDevice() {
    if (await Session.doesSessionExist()) {
        try {
            let deviceResponse = await Totp.createDevice();
            if (deviceResponse.status === "DEVICE_ALREADY_EXISTS_ERROR") {
                // this should only come here if you are passing a custom device name when calling the above function.
                throw new Error("Should never come here")
                // device created successfully
            }
            // device created successfully
            let qrCodeString = deviceResponse.qrCodeString;
            let secret = deviceResponse.secret;

            // TODO: display a QR code based on qrCodeString, and also an option to view
            // the secret if the user is unable to scan the QR code.
        } catch (err: any) {
            if (err.isSuperTokensGeneralError === true) {
                // this may be a custom error message sent from the API by you.
                window.alert(err.message);
            } else {
                window.alert("Oops! Something went wrong.");
            }
        }
    } else {
        throw new Error("TOTP device creation can only happen after the first factor is complete and when a session exists")
    }
}
```

</TabItem>

<TabItem value="script">

```tsx
import supertokensTotp from "supertokens-web-js-script/recipe/totp"
import supertokensSession from "supertokens-web-js-script/recipe/session"
async function createNewTotpDevice() {
    if (await supertokensSession.doesSessionExist()) {
        try {
            let deviceResponse = await supertokensTotp.createDevice();
            if (deviceResponse.status === "DEVICE_ALREADY_EXISTS_ERROR") {
                // this should only come here if you are passing a custom device name when calling the above function.
                throw new Error("Should never come here")
                // device created successfully
            }
            // device created successfully
            let qrCodeString = deviceResponse.qrCodeString;
            let secret = deviceResponse.secret;

            // TODO: display a QR code based on qrCodeString, and also an option to view
            // the secret if the user is unable to scan the QR code.
        } catch (err: any) {
            if (err.isSuperTokensGeneralError === true) {
                // this may be a custom error message sent from the API by you.
                window.alert(err.message);
            } else {
                window.alert("Oops! Something went wrong.");
            }
        }
    } else {
        throw new Error("TOTP device creation can only happen after the first factor is complete and when a session exists")
    }
}
```

</TabItem>

</NpmOrScriptTabs>

</TabItem>

<TabItem value="mobile">

<AppInfoForm askForAPIDomain>

Call the following API when you want to know the status of any factor. Notice that the API call requires the session's access token as an input (this should be added by our frontend SDK automatically):

```bash
curl --location --request POST '^{form_apiDomain}^{form_apiBasePath}/totp/device' \
--header 'rid: totp' \
--header 'Authorization: Bearer ...'
```

</AppInfoForm>

The above API call returns the following response:

```json
{
    "status": "OK",
    "issuerName": "...",
    "deviceName": "TOTP Device 1",
    "secret": "....",
    "userIdentifier": "user@example.com",
    "qrCodeString": "..."    
} | {
    "status": "DEVICE_ALREADY_EXISTS_ERROR" | "GENERAL_ERROR"
}
```

</TabItem>

</FrontendCustomUITabs>

- When device registeration is successful, the API returns the `secret` and `qrCodeString` which are to be displayed to the user. For React apps, we recommend using the [react-qr-code library](https://github.com/rosskhanas/react-qr-code) to display the QR code.
- The API call can also take a `deviceName` (as a POST body prop) which attemps to create a TOTP device with the provideed name. A status of `"DEVICE_ALREADY_EXISTS_ERROR"` is returned in case a verified device with the input name already exists. In this case, you should ask the user to enter a different name. Note that this status is only returned in case you are passing in a custom device name. The default naming strategy is to name the device "TOTP Device N", where we start N from 1, and keep increasing it.
- A status of `"GENERAL_ERROR"` is returned in case you specifically return that from a backend API override.

Once a device has been created, and scanned, you need to ask the user to enter the TOTP and send that to the API as shown in Case 2 below.

#### Case 2 implementation: User needs to complete the TOTP challenge

TODO..

</CustomUIContent>

</PreBuiltOrCustomUISwitcher>

## Multi tenant setup

TODO..

## Protecting frontend and backend routes