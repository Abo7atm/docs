---
id: frontend-setup
title: Frontend setup
hide_title: true
show_ui_switcher: true
---

import MFAPaidBanner from '../community/reusableMD/mfa/MFAPaidBanner.mdx'
import TabItem from '@theme/TabItem';
import CustomAdmonition from "/src/components/customAdmonition"
import {PreBuiltOrCustomUISwitcher, PreBuiltUIContent, CustomUIContent} from "/src/components/preBuiltOrCustomUISwitcher"
import FrontendPreBuiltUITabs from "/src/components/tabs/FrontendPreBuiltUITabs"
import FrontendCustomUITabs from "/src/components/tabs/FrontendCustomUITabs"
import NpmOrScriptTabs from "/src/components/tabs/NpmOrScriptTabs"

<MFAPaidBanner />

# Frontend setup

<PreBuiltOrCustomUISwitcher>

<PreBuiltUIContent>

## Single tenant setup

The pre built UI provides support for the following MFA methods:
- TOTP
- Email / phone OTP

If you want other types of MFA (like magic links, or password), please consider checking out the custom UI second.

We start by initialising the MFA recipe on the frontend and providing the list of first factors as shown below:

<FrontendPreBuiltUITabs>

<TabItem value="reactjs">

```tsx
import supertokens from "supertokens-auth-react"
import ThirdPartyEmailPassword from "supertokens-auth-react/recipe/thirdpartyemailpassword"
import Passwordless from "supertokens-auth-react/recipe/passwordless"
import MultiFactorAuth from "superTokens-auth-react/recipe/multifactorauth"

supertokens.init({
    appInfo: {
        appName: "...",
        apiDomain: "...",
        websiteDomain: "...",
    },
    recipeList: [
        ThirdPartyEmailPassword.init( /* ... */),
        Passwordless.init({
             contactMethod: "EMAIL_OR_PHONE",
        }),
        // highlight-start
        MultiFactorAuth.init({
            firstFactors: ["emailpassword", "thirdparty"]
        })
        // highlight-end
    ]
})
```

</TabItem>

</FrontendPreBuiltUITabs>

In the above snippet, we have configured thirdparty and email password as first factors. The second factor is configured [on the backend](./backend-setup), and is determined based on the [`n` array in the MFA claim in the session](./important-concepts#how-are-auth-factors-marked-as-completed). For example:
- If the `n` array in the session is `["otp-email"]`, then we will show the user the enter OTP screen for the email associated with the first factor login.
- If the `n` array in the session is empty, that means no login challenge is needed anymore, and the user will be redirected to the success screen, which is `/` by default.
- If the `n` array has multiple items, we will show the user a [factor chooser screen](https://6571be2867f75556541fde98-xieqfaxuuo.chromatic.com/?path=/story/mfa-chooser--multiple-factors) using which they can decide which factor they want to continue with.

If you notice, in the above code snippet, we have added `Passwordless.init` as well, and this handles cases where the second factor is `otp-email` or `otp-sms`. For TOTP, we have a different recipe as shown later in this guide.

## Multi tenant setup
For a multi factor setup, the first factors is decided based on [the configuration of the tenant](./backend-setup#multi-tenant-setup). Each tenant has a `firstFactors` array configuration which will determine the login options shown for that tenant. For MFA, the login options will be determined by the [`requiredSecondaryFactors` config on the tenant](./backend-setup#multi-tenant-setup-1), or based on the customisations for `getMFARequirementsForAuth` on the backend.

To tell the frontend to dynamically load the factors based on the tenant, we need to give it four things:
- The current tenantId
- Enable dynamic login methods
- Add `MultiFactorAuth.init` to the recipe list without any configured `firstFactors`
- Init all the recipes that can be possibly used by any tenant as the first or second factor.

<FrontendPreBuiltUITabs>

<TabItem value="reactjs">

```tsx
import supertokens from "supertokens-auth-react"
import ThirdPartyEmailPassword from "supertokens-auth-react/recipe/thirdpartyemailpassword"
import Passwordless from "supertokens-auth-react/recipe/passwordless"
import MultiFactorAuth from "superTokens-auth-react/recipe/multifactorauth"
import Multitenancy from "supertokens-auth-react/recipe/multitenancy"

supertokens.init({
    appInfo: {
        appName: "...",
        apiDomain: "...",
        websiteDomain: "...",
    },
    // highlight-next-line
    usesDynamicLoginMethods: true,
    recipeList: [
        Multitenancy.init({
            override: {
                functions: (oI) => {
                    return {
                        ...oI,
                        // highlight-start
                        getTenantId: (input) => {
                            // Implement the following based on the UX flow you want for
                            // tenant discovery
                            return "TODO.."
                        }
                        // highlight-end
                    }
                }
            }
        }),
        ThirdPartyEmailPassword.init( /* ... */),
        Passwordless.init({
            contactMethod: "EMAIL_OR_PHONE",
        }),
        // highlight-start
        MultiFactorAuth.init()
        // highlight-end
    ]
})
```

</TabItem>

</FrontendPreBuiltUITabs>

- In the above code snippet, we have added `ThirdPartyEmailPassword` and  `Passwordless` as the auth methods. This works for a variety of use cases like:
    - The first factor for any tenant can be third party or email password login, and the second factor can be passwordless login (`otp-email` or `otp-sms`).
    - The first factor for any tenant can be email password, with, or without a second factor (like `otp-email`)..
    - The first factor for any tenant can be third party, with, or without a second factor (like `otp-email`)..
    - The first factor for any tenant can be passwordless login (with magic link), with or without a second factor (like `otp-email`).
    - You can even change `passwordles.init` to using `thirdpartypasswordless.init` if you want to have the first factor for any tenant to be thirdparty or passwordless login, with or without a second factor (like `otp-email`).
- We have initialised `MultiFactorAuth` without any configured `firstFactors` because we want the frontend to dynamically load the first factors based on the tenant. Therefore, we have also set `usesDynamicLoginMethods: true` in the `supertokens.init` call.
- We have initialised `Multitenancy` as well, and provided a skeleton for `getTenantId`. You need to implement this function based on the UX flow you want for tenant discovery. For examlpe, [here is a common UX flow in which we decide the tenant ID based on the current sub domain](/docs/thirdpartyemailpassword/common-customizations/multi-tenancy/sub-domain-login).

:::important
- If you do initialise the `firstFactors` array for `MultiFactorAuth.init()` on the frontend, it will be ignored when `usesDynamicLoginMethods: true` is set.
- If the tenant doesn't have the `firstFactors` array set, then the list of first factors that are rendered would be based on the [login methods that are enabled in that tenant's config](/docs/multitenancy/new-tenant#basic-tenant-creation).
:::

The second factor for a tenant is determined based on the [`secondaryFactors` config for the tenant](./backend-setup#multi-tenant-setup-1), or based on any custom implementation for the `getMFARequirementsForAuth` function. If the current user has specific MFA methods enabled for them, those will also be shown as options as well. Overall, the list of secondary factors will be used to build the [`n` array in the MFA claim in the session](./important-concepts#how-are-auth-factors-marked-as-completed). For example: 
- If the `n` array in the session is `["otp-email"]`, then we will show the user the enter OTP screen for the email associated with the first factor login.
- If the `n` array in the session is empty, that means no login challenge is needed anymore, and the user will be redirected to the success screen, which is `/` by default.
- If the `n` array has multiple items, we will show the user a [factor chooser screen](https://6571be2867f75556541fde98-xieqfaxuuo.chromatic.com/?path=/story/mfa-chooser--multiple-factors) using which they can decide which factor they want to continue with.

In the subsequent sections, we will walk through specific MFA setup examples for your reference.

## Handling misconfigurations

There can be situations of misconfigurations. For example:
- You may have enabled `otp-email` for a user as a secondary factor, but did not add `Passwordless` (or `ThirdPartyPasswordless`) in the `recipeList` on the frontend or backend.
- You may have enabled `otp-email` for a user that is a part of a tenant as a secondary factor, but did not set `passwordlessEnabled: true` for that tenant in which the user is a part of. 

There are of course other similar cases, and in all of them, the pre built UI on the frontend will throw an error which will be propagated to the error boundry of your app.

The way to solve these errors is to recheck your config and make sure that they are correct.

</PreBuiltUIContent>

<CustomUIContent>

After the first factor sign in is over, to know the next auth challenge, the frontend should rely on the session's access token payload MFA claim's `n` array. For example, the access token payload may have the following content:

```json
{
    "st-mfa": {
        "c": {
            "emailpassword": 1702877939,
        },
        "n": ["totp"]
    }
}
```

This means that the user has completed the email password login, and the next auth challenge is TOTP.

## Initialise the MFA recipe on the frontend

<FrontendCustomUITabs>

<TabItem value="web">

<NpmOrScriptTabs>

<TabItem value="npm">

```tsx
import SuperTokens from 'supertokens-web-js';
import Session from 'supertokens-web-js/recipe/session';
import MultiFactorAuth from 'supertokens-web-js/recipe/multifactorauth';

SuperTokens.init({
    appInfo: {
        apiDomain: "^{form_apiDomain}",
        apiBasePath: "^{form_apiBasePath}",
        appName: "...",
    },
    recipeList: [
        // other recipes...
        MultiFactorAuth.init()
    ],
});
```

</TabItem>

<TabItem value="script">

```tsx
import supertokens from "supertokens-web-js-script";
import supertokensSession from "supertokens-web-js-script/recipe/session";
import supertokens^{recipeNameCapitalLetters} from 'supertokens-web-js-script/recipe/^{codeImportRecipeName}'
import supertokensMultiFactorAuth from 'supertokens-web-js-script/recipe/multifactorauth';
supertokens.init({
    appInfo: {
        apiDomain: "^{form_apiDomain}",
        apiBasePath: "^{form_apiBasePath}",
        appName: "...",
    },
    recipeList: [
        // other recipes...
        supertokensMultiFactorAuth.init()
    ],
});
```

</TabItem>


</NpmOrScriptTabs>

</TabItem>

<TabItem value="mobile">

:::success
This step is not applicable for mobile apps. Please see the next section.
:::

</TabItem>

</FrontendCustomUITabs>

## Factor lifecycle overview

The overall lifecycle of a factor post sign in is as follows:

### Step 1: Asking for the first factor
This is the same as setting up a recipe as per the other recipe guides. So please follow those.

### Step 2: Checking the `n` array
After the first factor has been completed, the frontend needs to check the values of the `n` array:
- If this array is empty, then the user has completed MFA.
- If there are multiple values in this array, then the frontend needs to show these options to the user and ask them to pick one of them.
- If there is only one item, and it's not the `access-denied` factor ID, then the UI can directly ask t he user to complete that factor.
- If there is only one item, and it's the `access-denied` factor ID, then the UI can show the access denied screen, along with a logout button. You can read more about this later on in this page.

### Step 3: Checking for factor setup
Once the user has picked a specific factor (or if `n` contains just one item), you need to check if that factor has already been setup for that user. A factor is setup already if:
- For `totp`: The user has already added a totp device and verified it.
- For `otp-email`: The user has a passwordless loginMethod that has an email associated with it.
- For `link-email`: The user has a passwordless loginMethod that has an email associated with it. Note that this is not a valid secondary factor, but is a valie first factor.
- For `otp-sms`: The user has a passwordless loginMethod that has a phone number associated with it.
- For `link-sms`: The user has a passwordless loginMethod that has a phone number associated with it. Note that this is not a valid secondary factor, but is a valie first factor.
- For `emailpassword`: The user has an email password loginMethod.
- For `thirdparty`: The user has a third party loginMethod.

If the user has the factor already setup, you can skip the setup step and directly ask them for the challenge:
- For `totp`: Ask them to enter the OTP.
- For `otp-email`: Send them an email with the OTP, and ask them to enter the OTP.
- For `otp-sms`: Send them an SMS with the OTP, and ask them to enter the OTP.
- For `emailpassword`: Ask them to enter their password.
- For `thirdparty`: Ask them to login using the third party provider.

In case the user does not have the factor setup, you need to ask them to set it up first:
- For `totp`: Ask them to scan the QR code and enter the TOTP to verify the device.
- For `otp-email`: Ask them to enter their email and send them an email with the OTP. Once they enter the OTP, a passwordless user will be created and associated with their user object. Note that if you already have the user's email from another login method (see later), you do not need to ask them to enter their email again. In that way, it would be similar to as if the factor is already setup, but technically, it is not.
- For `otp-sms`: Ask them to enter their phone number and send them an SMS with the OTP. Once they enter the OTP, a passwordless user will be created and associated with their user object. Note that if you already have the user's phone number from another login method (see later), you do not need to ask them to enter their phone number again. In that way, it would be similar to as if the factor is already setup, but technically, it is not.
- For `emailpassword`: Ask them to enter their email and password. Once they enter the password, an email password user will be created and associated with their user object. Note that if you already have the user's email from another login method (see later), you do not need to ask them to enter their email again. In that way, it would be similar to as if the factor is already setup, but technically, it is not. Here you would be calling the sign up API, vs in the other case (where the factor is already setup), you would be calling the sign in API.
- For `thirdparty`: Ask them to login using the third party provider. Once they login, a third party user will be created and associated with their user object.

In the later guides of this recipe, we will walk through each of these use cases in detail. For now though, if you want to know the status of any factor, you can call the following API:

TODO... Write about calling API of MFA Info.

:::important
During factor setup, the backend may reject the setup request due to security reasons, in which case you will have to show an appropriate support request message so that the user can contact you to resolve the issue. This is explained in the later section in this page.
:::

</CustomUIContent>

</PreBuiltOrCustomUISwitcher>


## The access denied factor
TODO (when will this be shown?)

## Handling support cases
There are some situations in which users may be locked out of their accounts and would need you to do certain steps to unlock their accounts. These cases are:

TODO.