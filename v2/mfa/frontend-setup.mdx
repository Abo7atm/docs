---
id: frontend-setup
title: Frontend setup
hide_title: true
show_ui_switcher: true
---

import MFAPaidBanner from '../community/reusableMD/mfa/MFAPaidBanner.mdx'
import TabItem from '@theme/TabItem';
import CustomAdmonition from "/src/components/customAdmonition"
import {PreBuiltOrCustomUISwitcher, PreBuiltUIContent, CustomUIContent} from "/src/components/preBuiltOrCustomUISwitcher"
import FrontendPreBuiltUITabs from "/src/components/tabs/FrontendPreBuiltUITabs"
import FrontendCustomUITabs from "/src/components/tabs/FrontendCustomUITabs"
import NpmOrScriptTabs from "/src/components/tabs/NpmOrScriptTabs"
import AppInfoForm from "/src/components/appInfoForm"

<MFAPaidBanner />

# Frontend setup

<PreBuiltOrCustomUISwitcher>

<PreBuiltUIContent>

## Single tenant setup

The pre built UI provides support for the following MFA methods:
- TOTP
- Email / phone OTP

If you want other types of MFA (like magic links, or password), please consider checking out the custom UI second.

We start by initialising the MFA recipe on the frontend and providing the list of first factors as shown below:

<FrontendPreBuiltUITabs>

<TabItem value="reactjs">

```tsx
import supertokens from "supertokens-auth-react"
import ThirdPartyEmailPassword from "supertokens-auth-react/recipe/thirdpartyemailpassword"
import Passwordless from "supertokens-auth-react/recipe/passwordless"
import MultiFactorAuth from "superTokens-auth-react/recipe/multifactorauth"

supertokens.init({
    appInfo: {
        appName: "...",
        apiDomain: "...",
        websiteDomain: "...",
    },
    recipeList: [
        ThirdPartyEmailPassword.init( /* ... */),
        Passwordless.init({
             contactMethod: "EMAIL_OR_PHONE",
        }),
        // highlight-start
        MultiFactorAuth.init({
            firstFactors: ["emailpassword", "thirdparty"]
        })
        // highlight-end
    ]
})
```

</TabItem>

</FrontendPreBuiltUITabs>

In the above snippet, we have configured thirdparty and email password as first factors. The second factor is configured [on the backend](./backend-setup), and is determined based on the [`n` array in the MFA claim in the session](./important-concepts#how-are-auth-factors-marked-as-completed). For example:
- If the `n` array in the session is `["otp-email"]`, then we will show the user the enter OTP screen for the email associated with the first factor login.
- If the `n` array in the session is empty, that means no login challenge is needed anymore, and the user will be redirected to the success screen, which is `/` by default.
- If the `n` array has multiple items, we will show the user a [factor chooser screen](https://6571be2867f75556541fde98-xieqfaxuuo.chromatic.com/?path=/story/mfa-chooser--multiple-factors) using which they can decide which factor they want to continue with.

If you notice, in the above code snippet, we have added `Passwordless.init` as well, and this handles cases where the second factor is `otp-email` or `otp-sms`. For TOTP, we have a different recipe as shown later in this guide.

## Multi tenant setup
For a multi factor setup, the first factors is decided based on [the configuration of the tenant](./backend-setup#multi-tenant-setup). Each tenant has a `firstFactors` array configuration which will determine the login options shown for that tenant. For MFA, the login options will be determined by the [`requiredSecondaryFactors` config on the tenant](./backend-setup#multi-tenant-setup-1), or based on the customisations for `getMFARequirementsForAuth` on the backend.

To tell the frontend to dynamically load the factors based on the tenant, we need to give it four things:
- The current tenantId
- Enable dynamic login methods
- Add `MultiFactorAuth.init` to the recipe list without any configured `firstFactors`
- Init all the recipes that can be possibly used by any tenant as the first or second factor.

<FrontendPreBuiltUITabs>

<TabItem value="reactjs">

```tsx
import supertokens from "supertokens-auth-react"
import ThirdPartyEmailPassword from "supertokens-auth-react/recipe/thirdpartyemailpassword"
import Passwordless from "supertokens-auth-react/recipe/passwordless"
import MultiFactorAuth from "superTokens-auth-react/recipe/multifactorauth"
import Multitenancy from "supertokens-auth-react/recipe/multitenancy"

supertokens.init({
    appInfo: {
        appName: "...",
        apiDomain: "...",
        websiteDomain: "...",
    },
    // highlight-next-line
    usesDynamicLoginMethods: true,
    recipeList: [
        Multitenancy.init({
            override: {
                functions: (oI) => {
                    return {
                        ...oI,
                        // highlight-start
                        getTenantId: (input) => {
                            // Implement the following based on the UX flow you want for
                            // tenant discovery
                            return "TODO.."
                        }
                        // highlight-end
                    }
                }
            }
        }),
        ThirdPartyEmailPassword.init( /* ... */),
        Passwordless.init({
            contactMethod: "EMAIL_OR_PHONE",
        }),
        // highlight-start
        MultiFactorAuth.init()
        // highlight-end
    ]
})
```

</TabItem>

</FrontendPreBuiltUITabs>

- In the above code snippet, we have added `ThirdPartyEmailPassword` and  `Passwordless` as the auth methods. This works for a variety of use cases like:
    - The first factor for any tenant can be third party or email password login, and the second factor can be passwordless login (`otp-email` or `otp-sms`).
    - The first factor for any tenant can be email password, with, or without a second factor (like `otp-email`)..
    - The first factor for any tenant can be third party, with, or without a second factor (like `otp-email`)..
    - The first factor for any tenant can be passwordless login (with magic link), with or without a second factor (like `otp-email`).
    - You can even change `passwordles.init` to using `thirdpartypasswordless.init` if you want to have the first factor for any tenant to be thirdparty or passwordless login, with or without a second factor (like `otp-email`).
- We have initialised `MultiFactorAuth` without any configured `firstFactors` because we want the frontend to dynamically load the first factors based on the tenant. Therefore, we have also set `usesDynamicLoginMethods: true` in the `supertokens.init` call.
- We have initialised `Multitenancy` as well, and provided a skeleton for `getTenantId`. You need to implement this function based on the UX flow you want for tenant discovery. For examlpe, [here is a common UX flow in which we decide the tenant ID based on the current sub domain](/docs/thirdpartyemailpassword/common-customizations/multi-tenancy/sub-domain-login).

:::important
- If you do initialise the `firstFactors` array for `MultiFactorAuth.init()` on the frontend, it will be ignored when `usesDynamicLoginMethods: true` is set.
- If the tenant doesn't have the `firstFactors` array set, then the list of first factors that are rendered would be based on the [login methods that are enabled in that tenant's config](/docs/multitenancy/new-tenant#basic-tenant-creation).
:::

The second factor for a tenant is determined based on the [`secondaryFactors` config for the tenant](./backend-setup#multi-tenant-setup-1), or based on any custom implementation for the `getMFARequirementsForAuth` function. If the current user has specific MFA methods enabled for them, those will also be shown as options as well. Overall, the list of secondary factors will be used to build the [`n` array in the MFA claim in the session](./important-concepts#how-are-auth-factors-marked-as-completed). For example: 
- If the `n` array in the session is `["otp-email"]`, then we will show the user the enter OTP screen for the email associated with the first factor login.
- If the `n` array in the session is empty, that means no login challenge is needed anymore, and the user will be redirected to the success screen, which is `/` by default.
- If the `n` array has multiple items, we will show the user a [factor chooser screen](https://6571be2867f75556541fde98-xieqfaxuuo.chromatic.com/?path=/story/mfa-chooser--multiple-factors) using which they can decide which factor they want to continue with.

In the subsequent sections, we will walk through specific MFA setup examples for your reference.

## Handling misconfigurations

There can be situations of misconfigurations. For example you may have enabled `otp-email` for a user as a secondary factor, but did not add `Passwordless` (or `ThirdPartyPasswordless`) in the `recipeList` on the frontend. In such (and similar) situations, the pre built UI on the frontend will throw an error which will be propagated to the error boundry of your app. The way to solve these errors is to recheck the `recipeList` on the frontend, and make sure that it has all the recipes initialised that are needed for any factor configured on the backend.

</PreBuiltUIContent>

<CustomUIContent>

After the first factor sign in is over, to know the next auth challenge, the frontend should rely on the session's access token payload MFA claim's `n` array. For example, the access token payload may have the following content:

```json
{
    "st-mfa": {
        "c": {
            "emailpassword": 1702877939,
        },
        "n": ["totp"]
    }
}
```

This means that the user has completed the email password login, and the next auth challenge is TOTP.

## Initialise the MFA recipe on the frontend

<FrontendCustomUITabs>

<TabItem value="web">

<NpmOrScriptTabs>

<TabItem value="npm">

```tsx
import SuperTokens from 'supertokens-web-js';
import MultiFactorAuth from 'supertokens-web-js/recipe/multifactorauth';

SuperTokens.init({
    appInfo: {
        apiDomain: "...",
        apiBasePath: "...",
        appName: "...",
    },
    recipeList: [
        // other recipes...
        // highlight-next-line
        MultiFactorAuth.init()
    ],
});
```

</TabItem>

<TabItem value="script">

```tsx
import supertokens from "supertokens-web-js-script";
import supertokensMultiFactorAuth from 'supertokens-web-js-script/recipe/multifactorauth';
supertokens.init({
    appInfo: {
        apiDomain: "...",
        apiBasePath: "...",
        appName: "...",
    },
    recipeList: [
        // other recipes...
        // highlight-next-line
        supertokensMultiFactorAuth.init()
    ],
});
```

</TabItem>


</NpmOrScriptTabs>

</TabItem>

<TabItem value="mobile">

:::success
This step is not applicable for mobile apps. Please see the next section.
:::

</TabItem>

</FrontendCustomUITabs>

## Factor lifecycle overview

The overall lifecycle of a factor post sign in is as follows:

### Step 1: Asking for the first factor
This is the same as setting up a recipe as per the other recipe guides. So please follow those.

### Step 2: Checking the `n` array
After the first factor has been completed, the frontend needs to check the values of the `n` array:
- If this array is empty, then the user has completed MFA.
- If there are multiple values in this array, then the frontend needs to show these options to the user and ask them to pick one of them.
- If there is only one item, then the UI can directly ask the user to complete that factor.

### Step 3: Checking for factor setup
Once the user has picked a specific factor (or if `n` contains just one item), you need to check if that factor has already been setup for that user. A factor is setup already if:
- For `totp`: The user has already added a totp device and verified it.
- For `otp-email`: The user has a passwordless loginMethod that has an email associated with it.
- For `link-email`: The user has a passwordless loginMethod that has an email associated with it. Note that this is not a valid secondary factor, but is a valie first factor.
- For `otp-sms`: The user has a passwordless loginMethod that has a phone number associated with it.
- For `link-sms`: The user has a passwordless loginMethod that has a phone number associated with it. Note that this is not a valid secondary factor, but is a valie first factor.
- For `emailpassword`: The user has an email password loginMethod.
- For `thirdparty`: The user has a third party loginMethod.

If the user has the factor already setup, you can skip the setup step and directly ask them for the challenge:
- For `totp`: Ask them to enter the OTP.
- For `otp-email`: Send them an email with the OTP, and ask them to enter the OTP.
- For `otp-sms`: Send them an SMS with the OTP, and ask them to enter the OTP.
- For `emailpassword`: Ask them to enter their password.
- For `thirdparty`: Ask them to login using the third party provider.

In case the user does not have the factor setup, you need to ask them to set it up first:
- For `totp`: Ask them to scan the QR code and enter the TOTP to verify the device.
- For `otp-email`: Ask them to enter their email and send them an email with the OTP. Once they enter the OTP, a passwordless user will be created and associated with their user object. Note that if you already have the user's email from another login method (see later), you do not need to ask them to enter their email again. In that way, it would be similar to as if the factor is already setup, but technically, it is not.
- For `otp-sms`: Ask them to enter their phone number and send them an SMS with the OTP. Once they enter the OTP, a passwordless user will be created and associated with their user object. Note that if you already have the user's phone number from another login method (see later), you do not need to ask them to enter their phone number again. In that way, it would be similar to as if the factor is already setup, but technically, it is not.
- For `emailpassword`: Ask them to enter their email and password. Once they enter the password, an email password user will be created and associated with their user object. Note that if you already have the user's email from another login method (see later), you do not need to ask them to enter their email again. In that way, it would be similar to as if the factor is already setup, but technically, it is not. Here you would be calling the sign up API, vs in the other case (where the factor is already setup), you would be calling the sign in API.
- For `thirdparty`: Ask them to login using the third party provider. Once they login, a third party user will be created and associated with their user object.

In the later guides of this recipe, we will walk through each of these use cases in detail. For now though, if you want to know the status of any factor, you can call the following API:

<FrontendCustomUITabs>

<TabItem value="web">

<NpmOrScriptTabs>

<TabItem value="npm">

```tsx
import MultifactorAuth from "supertokens-web-js/recipe/multifactorauth"
import Session from "supertokens-web-js/recipe/session"

async function fetchMFAInfo() {
    if (await Session.doesSessionExist()) {
        try {
            let mfaInfo = await MultifactorAuth.resyncSessionAndFetchMFAInfo()
            let factorEmails = mfaInfo.emails;
            let factorPhoneNumbers = mfaInfo.phoneNumbers;

            let emailsForOTPEmail = factorEmails["otp-email"];
            let phoneNumbersForOTPSms = factorEmails["otp-sms"];
            let isTotpSetup = mfaInfo.factorsThatAreAlreadySetup.includes("totp");
            let isOTPEmailSetup = mfaInfo.factorsThatAreAlreadySetup.includes("otp-email");
            let isOTPSmsSetup = mfaInfo.factorsThatAreAlreadySetup.includes("otp-sms");
        } catch (err: any) {
            if (err.isSuperTokensGeneralError === true) {
                // this may be a custom error message sent from the API by you.
                window.alert(err.message);
            } else {
                window.alert("Oops! Something went wrong.");
            }
        }
    } else {
        throw new Error("Illegal function call: For first factor setup, you do not need to call this function")
    }
}
```

</TabItem>

<TabItem value="script">

```tsx
import supertokensMultiFactorAuth from "supertokens-web-js-script/recipe/multifactorauth"
import supertokensSession from "supertokens-web-js-script/recipe/session"
async function fetchMFAInfo() {
    if (await supertokensSession.doesSessionExist()) {
        try {
            let mfaInfo = await supertokensMultiFactorAuth.resyncSessionAndFetchMFAInfo()
            let factorEmails = mfaInfo.emails;
            let factorPhoneNumbers = mfaInfo.phoneNumbers;

            let emailsForOTPEmail = factorEmails["otp-email"];
            let phoneNumbersForOTPSms = factorEmails["otp-sms"];
            let isTotpSetup = mfaInfo.factorsThatAreAlreadySetup.includes("totp");
            let isOTPEmailSetup = mfaInfo.factorsThatAreAlreadySetup.includes("otp-email");
            let isOTPSmsSetup = mfaInfo.factorsThatAreAlreadySetup.includes("otp-sms");
        } catch (err: any) {
            if (err.isSuperTokensGeneralError === true) {
                // this may be a custom error message sent from the API by you.
                window.alert(err.message);
            } else {
                window.alert("Oops! Something went wrong.");
            }
        }
    } else {
        throw new Error("Illegal function call: For first factor setup, you do not need to call this function")
    }
}
```

</TabItem>

</NpmOrScriptTabs>

- In the above code snippet, we fetch all the relevant information to know what state a factor is in so that we can decide if we should ask the user to setup the factor (for example create a new TOTP device), or just ask them to solve the auth challenge instead (for example, showing the enter TOTP screen).
- The function is called `resyncSessionAndFetchMFAInfo` because it does two things:
    - fetches the MFA info that you can consume to decide what state a factor is in.
    - resyncs the value of the `n` array in the session's access token payload. As such, it's theoretically possible that the `n` array has changed when we call this function, so we should re-check if the current factor (that we are going to show the user) is still in the `n` array.


</TabItem>

<TabItem value="mobile">

<AppInfoForm askForAPIDomain>

Call the following API when you want to know the status of any factor. Notice that the API call requires the session's access token as an input:

```bash
curl --location --request PUT '^{form_apiDomain}^{form_apiBasePath}/mfa/info' \
--header 'rid: multifactorauth' \
--header 'Authorization: Bearer ...'
```

</AppInfoForm>

- In the above code snippet, we fetch all the relevant information to know what state a factor is in so that we can decide if we should ask the user to setup the factor (for example create a new TOTP device), or just ask them to solve the auth challenge instead (for example, showing the enter TOTP screen).
- The API is `PUT` and not `GET` because it does two things:
    - fetches the MFA info that you can consume to decide what state a factor is in.
    - resyncs the value of the `n` array in the session's access token payload. As such, it's theoretically possible that the `n` array has changed when we call this function, so we should re-check if the current factor (that we are going to show the user) is still in the `n` array.

</TabItem>

</FrontendCustomUITabs>

- The struture of the raw JSON response is as follows:
    ```json
    {
        "status": "OK",
        "factorsThatAreAlreadySetup": ["totp", "otp-email", "..."],
        "emails": {
            "otp-email": ["user1@example.com", "user2@example.com"],
            "link-email": ["user1@example.com", "user2@example.com"],
        },
        "phoneNumbers": {
            "otp-sms": ["+1234567890", "+1098765432"],
            "link-sms": ["+1234567890", "+1098765432"],
        }
    }
    ```

    - `factorsThatAreAlreadySetup` is an array that contains all factors that have been setup by the user. If the current factor is a part of this array, it means that you can directly take the user to the factor challenge screen. If your factor depends on an email or phone number (like in the case of `otp-sms` or `otp-email`), then you can find the email to send the code to in the `emails` or `phoneNumbers` object in the response with the key as the current factor ID.
    - `emails` is an object in which the key are all the factor IDs support by SuperTokens (and any custom factor ID added by you). The values against each of the keys is a list of emails that can be used to complete the factor. The first email (inddex 0) in the list is the preferred email to use for the factor. We calculate the order based on the first factor chosen by the user, and if the factor was already setup or not.

    If the array is empty, it means that there is no email associated with the user for that factor. This can happen only if the factor was not already setup. In this case, you should take the user to a screen to ask them to first enter an email, and then to the challenge screen.

    We will further go into this flow in our common flows guide later on.
    - `phoneNumbers` is similar to the `emails` object, except that it contains phone numbers for factors that are based on phone numbers.

:::important
During factor setup, the backend may reject the setup request due to security reasons, in which case you will have to show an appropriate support request message so that the user can contact you to resolve the issue. This is explained in the later section in this page.
:::

</CustomUIContent>

</PreBuiltOrCustomUISwitcher>

## Handling support cases
There are some situations in which users may be locked out of their accounts and would need you to do certain steps to unlock their accounts. These cases are:

TODO.